%----------------------------------------------------------------------------------------
%	PA%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath,amssymb,array}

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[margin=1in,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions
\usepackage{booktabs} % Horizontal rules in tables
% \usepackage{subfig} % Sub figures
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx} % better graphics
\usepackage{float}
\usepackage[dvipsnames]{xcolor} % colors

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage[T1]{fontenc}
\usepackage{listings} % for numbers in code chunks

% macro to select a scaled-down version of Bera Mono (for instance)
\makeatletter
\newcommand\BeraMonottfamily{%
  \def\fvm@Scale{0.85}% scales the font down
  \fontfamily{fvm}\selectfont% selects the Bera Mono font
}
\makeatother

\lstset{
  basicstyle=\BeraMonottfamily,
  frame=single,
}


\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{nameref} % \Cref command automatically handles figure/table/etc refs

\usepackage{natbib}
\bibliographystyle{abbrvnat}

% Commands for editing
\newcommand{\hh}[1]{{\textcolor{orange}{#1}}}
\newcommand{\svp}[1]{{\textcolor{blue}{#1}}}
\newcommand{\au}[1]{{\textcolor{ForestGreen}{#1}}}

\newcommand{\code}[1]{\texttt{{#1}}}
\newcommand{\pkg}[1]{\texttt{{#1}}}
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{A grammar of graphics framework for generalized parallel coordinate plots} % Article title
\author{%
\textsc{Author 1}$^1$\thanks{Corresponding author: \href{mailto:xxx}{xxx}}\hspace{2em}
\textsc{Author 2}$^2$\hspace{2em}
\textsc{Author 3}$^3$\\[1ex] % Your name
{\footnotesize
$^1$ University 1;
$^2$ University 2;
$^3$ University 3
} %
}
\date{\today} % Leave empty to omit a date

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle
\begin{abstract}
\noindent
\noindent Parallel coordinate plots (PCP) are a useful tool in exploratory data analysis of high-dimensional numerical data. The use of PCPs is limited when working with categorical variables or a mix of categorical and continuous  variables. In this paper, we propose generalized parallel coordinate plots (GPCP) to extend the ability of PCPs from just numeric variables to dealing seamlessly with a mix of categorical and numeric variables in a single plot. In this process we find that existing solutions for categorical values only, such as hammock plots or parsets become edge cases in the new framework. By focusing on individual observations rather than a marginal frequency we gain additional flexibility. The resulting approach is implemented in the R package ggpcp.

\end{abstract}

\tableofcontents
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

<<setup, echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE>>=
library(knitr)
knitr::opts_chunk$set(fig.path="figures/", echo=FALSE, out.width = '\\linewidth', warning=FALSE, message=FALSE, cache = TRUE)
@


<<setup2, echo=FALSE, cache=FALSE>>=
knit_hooks$set(source = function(x, options) {
    paste("\\begin{lstlisting}[numbers=left, firstnumber=last]\n", x,
        "\\end{lstlisting}\n", sep = "")
})
knit_hooks$set(reset = function(before, options, envir){
if(before){
    return("\\setcounter{lstnumber}{1}")
}
})
@

<<packages, echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE>>=
library(tidyverse)
library(ggpcp)
library(gridExtra)

theme_set(theme_bw())
@

\section{Introduction}

Few approaches in data visualization exist that are truly high-dimensional. Most visualizations are projections of data into two or three dimensions enhanced by facetting or additional mappings to plot aesthetics, such as point size and color.
Parallel coordinate plots are one of the exceptions: in parallel coordinate plots we can actually visualize an arbitrary many number of variables to get a visual summary of a high-dimensional data set. In a parallel coordinate plot, each variable takes the role of a vertical (or parallel) axis; giving the visualization its name. Multivariate observations are then plotted by connecting their respective values on each axis across all axes using polylines (cf. \autoref{fig:sketch}). For just two variables this switch from orthogonal axes to parallel axes is equivalent to a switch from the familiar Euclidean geometry to the Projective Space. In the projective space, points take the role of lines, while lines are replaced by points, i.e. points falling on a line in the Euclidean space correspond to lines crossing in a single point in the Projective Space.
% \svp{, as shown in \autoref{fig:projective-space}}.
This duality provides a good basis for interpreting geometric features observed in a parallel coordinate plot \citep{Inselberg:1985}.

<<projective-space, echo = F, out.width = "\\linewidth", fig.cap = "Parallel coordinate plots show the data in the projective space rather than the Euclidean space, allowing for more dimensions to be shown on the same plot.", fig.width = 8, fig.height = 3, include = F>>=
library(palmerpenguins)
data(penguins)
p1 <- ggplot(penguins, aes(x = body_mass_g, y = bill_depth_mm, color = species)) + geom_point() +
  ggtitle("Points in Euclidean space")

library(ggpcp)
p2 <- penguins %>%
  pcp_select(body_mass_g, bill_depth_mm) %>%
  pcp_scale() %>%
  pcp_arrange(method="from-left") %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour=species), alpha=0.8, overplot="none") +
  geom_pcp_labels(alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  ggtitle("Lines in Projective Space")

library(patchwork)

p1 + p2 + plot_layout(nrow = 1, byrow = FALSE)
@

The origins of parallel coordinate plots date back to the 19th century and are, depending on the source, either attributed to  \citet{dOcagne:1885} or  \citet{Gannett:1880}.
Modern era parallel coordinate plots go back to  \citet{Inselberg:1985} and \citet{Wegman:1990}. Parallel coordinate plots are used in an exploratory setting as a way to get a high-level overview of the marginal distributions involved, to identify outliers in the data, and to find potential clusters of points. In the absence of those, Parallel Coordinate Plots are often criticized for the amount of clutter they produce, resembling a game of mikado (also known as pickup-sticks -- if you are not familiar with the game, imagine spilling a box of  spaghetti) rather than organized data.
This clutter is sometimes mitigated by the use of $\alpha$-blending \citep{alpha-blending}, density estimation \citep{density-pcp}, or edge-bundling parallel coordinate plots \citep{edge-bundling}. For a detailed overview of these and other techniques see \citet{review}.

% However, parallel coordinate plots have some shortcomings. \hh{XXXX after bashing clutter in pcps, `some shortcomings' feels like rubbing it in :)} The biggest challenge comes when working with categorical variables.
\svp{While parallel coordinate plots have some shortcomings, the greatest challenge is in using categorical variables.} In current solutions such as the \code{scpcp} function in the \code{extracat} package\citep{cpcp}, levels of categorical variables are transformed to numbers and variables are then used as if they were numeric. This
% \hh{XXX if it doesn't introduce ties, are we still talking about categorical data or have we switched to identifiers? - with identifiers we could deal this way} % svp - fair point.
introduces
%a lot of
ties into the data, and the resulting parallel coordinate plot becomes uninformative, as it only shows lines from each level of one variable to all levels of the next variable.
Some versions of parallel coordinate plots have been specifically developed to deal with categorical data: parallel set plots \citep{Kosara:2006}, Hammock plots \citep{Schonlau:2003}, and common angle plots \citep{Hofmann:2013}.
These solutions are intended for use with tabularized data and show bands of observations from one categorical variable to the next. Hammock plots and common angle plots mitigate the sine-illusion's effects \citep{sine, susan:2015} on parallel sets plots.
An attempt to combine categorical and numeric variables in a parallel coordinate plot is introduced in the categorical parallel coordinate plots of \citet{cpcp}.
These plots provide an extension to parallel sets that allows numeric variables to be included in the plot.
Similar to parallel sets, this approach is also based on marginal frequencies for the categorical variables.
Categorical parallel coordinate plots are the closest of these variations to our solution, \svp{but the \pkg{extracat} package has not been updated recently and is no longer on CRAN.}
%they are not implemented in the \pkg{ggplot2} framework and can therefore not be further extended.\svp{They can't be extended because they're not implemented in ggplot2, or it's just not convenient to implement them first and then extend them? Surely there's an actual structural difference between the approach here and cpcps?}


Various packages in R \citep{R} exist that contain an implementation of one of the \svp{types of} parallel coordinate plots \svp{discussed above}.
The function "parcoord" in the \pkg{MASS} package \citep{MASS} makes use of the base plot system of R to draw parallel coordinate plots.
The function "cpcp" in package \pkg{iplots} implemented the parallel coordinate plot \citep{cpcp}, \svp{but the function is not available in modern versions of the package}.
Developments based on the grammar of graphics \citep{wilkinson:1999} and the \pkg{ggplot2} \citep{ggplot2} framework are, e.g. the functions `ggparcoord' in \pkg{GGally} \citep{GGally} or \pkg{ggparallel} \citep{ggparallel} which provide an implementation of Hammock and common-angle plots.
% \svp{We may want to integrate this paragraph into the previous paragraph, or provide graphical examples of the different plots?}
Those packages based on \pkg{ggplot2} make use of \pkg{ggplot2}, but are actually wrapper of existing functions for highly specialized plots with tens of parameters, which do not allow the full flexibility of \pkg{ggplot2} and do not make use of \pkg{ggplot2}'s  layer framework.
% \svp{Might be useful to actually provide an example of the syntax/underlying code here or in an appendix?}

<<sketch, warning=FALSE, results='asis', fig.width = 9, fig.height = 3, fig.cap="Sketch of a parallel coordinate plot of two observations in four dimensions. Each dimension is shown as a vertical axis, observations are connected by polylines from one axis to the next. ">>=
df <- data.frame(x1 = c(1,2), x2 = c(0, 0.5), x3=c(2,1), x4=c(2,3), id=c(1,2))
df %>%
  pcp_select(x1:x4) %>%
#  mutate(value = parse_number(as.character(value))) %>%
  pcp_scale(method="globalminmax") %>%
  ggplot(aes_pcp())  +
  geom_pcp_axes() +
  geom_pcp(aes(colour = factor(pcp_id)), size=1) +
  geom_point(aes(shape=factor(pcp_id), colour = factor(pcp_id)), size=5) +
  theme_bw() +
  xlab("") +
  scale_shape_discrete("Observation") +
  scale_colour_manual("Observation", values=c("darkorange", "purple4")) +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete(expand = expansion(add=0.2))
@


The remainder of the paper is organized as follows:
\svp{\autoref{sec:usage} introduces the \pkg{ggpcp} syntax and explains the improvements in \pkg{ggpcp} over other parallel coordinate plot software packages.}
\autoref{sec:wrangling} describes the data processing for parallel coordinate plots \svp{and how this wrangling is separated from the plot rendering in \pkg{ggpcp}.}
\svp{\autoref{sec:visual} discusses the rendering of parallel coordinate plots and factors such as plotting order and tie-breaking which are important for the design of PCPs.}
\svp{\autoref{sec:examples} provides three examples which highlight the use of generalized PCPs in exploratory settings.}
% Section 3  presents the conceptual framework of  generalized parallel coordinate plots and general principles informing their construction. Section 4 describes the connection between generalized parallel coordinates and the grammar of graphics. Section 5 provides three examples highlighting different aspects of the use of  generalized parallel coordinate plots in an exploratory setting.

\section{Motivation and Package Usage}\label{sec:usage}

\hh{XXX We need to state what this code is about: paper structured along how code is used.}
<<echo=FALSE, results = 'hide', error=FALSE, warning=FALSE, cache=FALSE>>=
library(GGally)
data(flea)
@

<<echo=TRUE, reset=TRUE,  results = 'hold', error=FALSE, warning=FALSE>>=
pcp <- flea %>%                           # data management:
  pcp_select(species, 2:7, species) %>%   #   variable selection, see section 3.1
  pcp_scale(method="uniminmax") %>%       #   setting scaling method, see section 3.2
  pcp_arrange() %>%                       #   arranging categorical data
  ggplot(aes_pcp()) +                     # plotting the chart:
    geom_pcp_axes() +                     #   vertical lines for axes
    geom_pcp(aes(colour = species))       #   parallel coordinate line segments
@


By leveraging the full ggplot2 philosophy instead of using highly specific wrapper functions, \pkg{ggpcp} allows users to focus on the data, rather than the names of various parameters used for customization.
\pkg{ggpcp} adopts tidy conventions for data wrangling, separating the necessary data manipulation to generate a parallel coordinate plot from the visual rendering. Scaling, ordering of cases, and the arrangement of the parallel axes are completed using  \code{pcp\_select}, \code{pcp\_arrange}, and \code{pcp\_scale},respectively; the resulting data frame is then passed directly into the familiar \code{ggplot()} call.
During the plotting state, the only modification from default \pkg{ggplot2} syntax is the use of \code{aes\_pcp()} in place of \code{aes()}; this is necessary to handle the multiple axes in a parallel coordinate plot while maintaining the ability to map all other variables of the original data frame to aesthetics such as linetype and color.
The user has complete control over layers such as PCP lines (\code{geom\_pcp}), labels (\code{geom\_pcp\_labels}), and boxes around categorical variables (\code{geom\_pcp\_boxes}), but there are additional advantages to the use of \pkg{ggplot2}.
Users can also augment their parallel coordinate plots with additional information, such as boxplots or violin plots, with standard ggplot2 syntax.

One of the strengths of \pkg{ggplot2} is its handling of small multiple plots with \code{facet\_grid} and \code{facet\_wrap}; these functions are fully supported in \pkg{ggpcp}.

In addition, basing \pkg{ggpcp} on \pkg{ggplot2} expands the functionality available to users without much additional code, thanks to other packages such as \pkg{plotly}~\citep{plotly-book}  and \pkg{gridsvg}~\citep{gridsvg} which leverage \pkg{ggplot2} to create interactive graphics for the web.

%------------------------------------------------

\section{Data management}\label{sec:wrangling}
%------------------------------------------------

The idea behind this re-implementation of parallel coordinate plots is to expose parallel coordinate plots at a functional level. Rather than using a single function with parameters controlling every aspect, we separate the data management from the visual rendering.
\hh{In particular, we separate out the data management into three parts:}
\begin{enumerate}
\item Variable selection and reshaping data,
\item Scaling of axes, both at the individual level and in the relationship of the axes to each other, and
\item Treatment of ties in categorical axes.
\end{enumerate}

\hh{The modularization of the data wrangling process has the additional advantage to lay out the necessary elements in successive steps. Some of these steps are even optional - e.g. scaling variables might not be necessary, if all variables are already on the same scale (i.e. method `raw` in GGally); similarly, using pcp\_arrange to break ties is only necessary if there are any factor variables, and if we actively want to spread these observations out. }
\svp{In addition, by exposing these elements of the pcp data wrangling process, we allow users to create additional functions for handling these tasks.}

\hh{The treatment of ties is an aspect not generally addressed in the original parallel coordinate plots of \citet{Inselberg:1985} and \citet{Wegman:1990}. We have found a need to deal with ties, because ties are visually the main obstacle of allowing the viewer to follow an observation from axis to axis through the high-dimensional space.}
\svp{If we can track a single observation through the high-dimensional space, we have the ability to look beyond two-variable comparisons (sequential axes). This allows users to more easily summarize main trends and identify observations which do not follow those trends. When ties are not handled appropriately and users cannot follow individual observations, higher-dimensional insights are next to impossible.}
% \hh{Once this assessment is broken for the individual observation, the  we cannot reasonably expect to gain much more information by plotting more data in the plot. XXX this is clumsy - what I am really aiming for needs a bit more: the way plots should be used in order to make sense of complicated situations is  to provide (1) a visual summary of the main trends and (2) allow us to identify observations that do not follow those trends. By mapping all plots that have the same value on one dimension into a single point on an axis, we hinder any higher-dimensional insights.}

\subsection{Variable selection and Order of the variables}

One of the biggest strengths of the Grammar of Graphics is its mapping between data variables and visual aesthetics.
In standard plots any mapping is a function between one aesthetic and one data variable.
In a parallel coordinate plot, this one-to-one mapping between data and plot aesthetics is seemingly turned into a one-to-many mapping between arbitrarily many data variables to the x axis.
By transforming the wide form of the data set into a long form \citep{reshape, dplyr, jss.tidy, hadley.tidy}, we get to a form of the dataset in which we achieve a one-to-one mapping to a now discrete x axis consisting of the (names of the) original data variables.

\begin{figure}
%\includegraphics[width=\linewidth]{sketches/data-wrangling.pdf}
\includegraphics[width=\linewidth]{sketches/data-wrangling-plus.pdf}
\caption{\label{sketch:wrangling}The user selects a set of three variables (top left). On the right, an overview of the data wrangling step  before a parallel coordinate plot can be drawn (bottom left). Note that the order in which variables are selected is reflected in the order in which variables are included in the parallel coordinate plot.}
\end{figure}

\hh{From the user's perspective this data reshaping has purely the form of a data selection, while the data wrangling is going on behind the scenes in \code{pcp\_select}.}

\code{pcp\_select(data, ...)} allows a selection of variables to be included in the parallel coordinate plot.
Variables can be specified by an any combination of the following methods:

\begin{itemize}
\item position, e.g. \code{1:4, 7, 5, 4},
\item name, e.g. \code{class, age, sex, aede1:aede3} or
\item using pattern selectors, e.g. \code{starts\_with("aede")}, see \code{?tidyselect::select\_helpers}
\end{itemize}

Variables can be selected multiple times and will then be included in the data and the resulting plot multiple times.
Note that the order in which variables are selected determines the order in which the corresponding axis is drawn in the parallel coordinate plots.
\code{pcp\_select} transforms the selected variables to long form and embellishes the data set with a number of additional variables. All of the newly created and added variables start with the prefix \code{pcp\_}:
\begin{itemize}
\item \code{pcp\_x}: discrete variable consisting of the names of the selected variables in the order that they were selected - this is the order in which the variables will be included in the plot.
\item \code{pcp\_y}: numeric variable containing the values of all of the selected variables. In case a selected variable is not numeric, it is converted to a factor variable and the (numeric) factor levels are saved in \code{pcp\_y}.
\item \code{pcp\_level}: character variable containing the factor levels of selected data variables. In case of numeric variables, the data values are stored (in textual form). \svp{The ordering of factor variables will be discussed below but is implemented using this added variable.}
\item \code{pcp\_class}: character variable containing the class information of a selected variable.
\item \code{pcp\_id}: integer variable identifying each observation in the original dataset. This variable will be used as grouping variable to identify which values should be connected by a line segment in the parallel coordinate plot.
\end{itemize}

\svp{As a consequence of these design decisions, users have several ways to perform different tasks within the flow of generating data for a parallel coordinate plot. For instance, users can reorder variables using \code{pcp\_select} or after variable selection using the \code{pcp\_x} variable.}

% <<reordering-variables-axis1>>=
% flea %>%
%   pcp_select(species, 5:7, 2:4, species) %>%
%   pcp_scale(method="uniminmax") %>%
%   pcp_arrange() %>%
%   ggplot(aes_pcp()) +
%     geom_pcp_axes() +
%     geom_pcp(aes(colour = species))
% @
% <<reordering-variables-axis1>>=
% library(forcats)
% flea %>%
%   pcp_select(species, 2:7, species) %>%
%   pcp_scale(method="uniminmax") %>%
%   dplyr::mutate(
%     pcp_x = fct_relevel(pcp_x, c("species", "aede1", "aede2", "aede3",
%                                  "tars1", "tars2", "head", "species.1"))
%     ) %>%
%   pcp_arrange() %>%
%   ggplot(aes_pcp()) +
%     geom_pcp_axes() +
%     geom_pcp(aes(colour = species))
% @
% \hh{XXX reordering variables in the parallel coordinate plot could be done before the selection by pcp\_select or after it by re-ordering the levels in the pcp\_x variable. We should probably include an example.} % I think that it's a lot more complicated to reorder pcp_x, to be honest. I've written the code to do it, but it's ugly.

\hh{XXX univariate transformations, such as reversing an axis for a variable can be done using a mutate statement before the variable selection. example? changing order of levels on a categorical variable or a log transform or square root transformation work the same. }

<<reordering-variables-axis1, fig.width = 8, fig.height = 4, fig.cap = "Mutations before the \\code{pcp\\_select} stage can be used to reorder factors or transform numerical variables.", echo = TRUE, reset = TRUE>>=
flea %>%
  mutate(
    species_inv = factor(species, levels = rev(levels(.$species))),
    head_sqrt = log(head)) %>%
  pcp_select(species, 2:4, head_sqrt, 5:7, species_inv) %>%
  pcp_scale(method="uniminmax") %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
    geom_pcp_axes() +
    geom_pcp(aes(colour = species))
@

\hh{Ordering of levels in factor variables (XXX not sure where to put this, yet):
  What we are doing with the ordering of levels in factor variables, is to stick with the basic interpretation of factor variables as a type of variable that has both labels and an ordering of those labels. Whenever we assign a numeric value to the ordering, we refer to the associated score, which is an integer value from one to the number of categories, if not specified explicitly otherwise. This means in particular, that the first level of a categorical variable is mapped to the lowest value along the $y$ axis rather than the `top` value as e.g. when mapped to `fill`  in a barchart. }
\hh{This might lead to a visual inconsistency between the orderings in the levels of a categorical variable and an accompanying color legend. In those situations we suggest to reverse the order in the legend by using the command \code{guides(color = guide\_legend(reverse=TRUE))} as shown in the example in \autoref{sec:carcinoma}.}
<<colorscheme>>=
#####  Color Palette by Paletton.com
#####  Palette URL: http://paletton.com/#uid=3140R0kllllaFw0g0qFqFg0w0aF


# *** Primary color:
primary = c("#AA8939", "#FFE7AA", "#D4B66A", "#806115", "#553D00")

# *** Secondary color (1):

secondary = c("#5A2971", "#9974AA", "#784A8E", "#3F1255", "#270339")

# *** Secondary color (2):

tertiary = c("#277552", "#75B095", "#499371", "#0F5837", "#003B20")

#####  Generated by Paletton.com (c) 2002-2014
@

<<scale, fig.cap="Two scaling methods showing fatty acid compositions of  olive oils from different regions in Italy, areas within each region are colored using similar hues within region (green for Northern Italy, purple for Sardinia, and tans for Southern Italy).\\hh{robust scale: median to 0 check units XXX} The two scaling methods roughly allow the same conclusions.", fig.height = 8, fig.width = 8>>=
#crabs <- read.csv("http://ggobi.org/book/data/australian-crabs.csv")
#prim7 <- read.csv("http://ggobi.org/book/data/prim7.csv")
data("olive", package="tourr")

oils <- olive %>% mutate(
  area = reorder(area, region)
)
# oils <- oils %>% mutate(
#   X = gsub("[0-9]+.", "", X),
#   X = reorder(X, area),
#   area = X
# )

# oils <- oils %>% mutate(
#     palmitic = -palmitic,
#     palmitoleic = -palmitoleic
#   )

dt1 <- oils %>%
  mutate(
    region=factor(region)
    ) %>%
  pcp_select(region, area, palmitic:eicosenoic) %>%
  pcp_scale(method = "uniminmax") %>%
  pcp_arrange(space = 0.2)
dt1$scaling <- "uniminmax"

dt2 <- oils %>%
  mutate(
    region=factor(region)
    ) %>%
  pcp_select(region, area, palmitic:eicosenoic) %>%
  pcp_scale(method = "robust") %>%
  pcp_arrange(space = 0.2)
dt2$scaling <- "robust"

dt <- rbind(dt1, dt2)


dt %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes() +
  geom_pcp(aes(colour = area), alpha = 0.5, overplot="none") +
  facet_grid(scaling~., labeller="label_both", scales="free_y") +
  scale_colour_manual(values = c(primary[c(2,4,3,1)], secondary[1:2], tertiary[1:3])) +
  theme_bw() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(override.aes = list(alpha=1, size = 2), reverse=TRUE)) +
  scale_x_discrete(expand = expansion(add=0.3)) +
  xlab("") +
  ylab("")
@

\subsection{Scaling}

\code{pcp\_scale(data, method)} scales the values on each axis and determines the relative relationship of the axes to each other.

\code{method} is a character string specifying the method to be used when transforming the values of each variable into a common y axis. By default, the method \code{uniminmax} is chosen, which univariately scales each variable into a range of [0,1] with a minimum at 0 and the maximum at 1. \code{globalminmax} maps the values across all axes into a an interval of [0,1]. This method should only be used if the values across all variables are comparable. %\svp{XXX Need to discuss \code{std} here if you're going to use it in \autoref{fig:scale}.}\hh{XXX switched to more interesting scaling and explained it :) }
The method \code{robust} normalizes values univariately by mapping the median value to 0.5 and a robust 95\% confidence interval (based on the median absolute deviation) to an interval of 0 to 1.

%\hh{Does the method 'raw' do anything? I think we could have the same effect by simply skipping this part of the processing. It's a nice example, where something that needed para metrization in another implementation is automatically implemented here by not doing anything. }



\autoref{fig:scale} shows  two of the scaling methods at the example of the olive oil data  \citep{ggobi, tourr, forina}: measurements of fatty acids in 572 olive oils from three different regions in Italy are visualized as parallel coordinate plots. Similar to the findings in \citet{ggobi}, we see that eicosenoic acid is only found in increased quantities in olive oils from Southern Italy. Quantities of oleic and linoleic acids allow a separation between olive oils from Sardinia and Northern Italy. Both scaling methods enable us to find these conclusions. While uniminmax scaling uses the space alloted to the chart most efficiently, the robust normalization method emphasizes the heavy tails and skewness of some of the measurements, such as the percentages of stearic and arachidic fatty acids.


\section{Visual Rendering}\label{sec:visual}


\subsection{Breaking ties on categorical axes}

\hh{XXX How to deal with ties has a huge visual impact. In order to get to that we need to do some more data wrangling. This subsection is somewhere between data management and visualization. }

\hh{XXX it might be good to separate the section into 'how' (data) and 'why' (visual aspects).}




\code{pcp\_arrange(data, method, space)} provides a rescaling of values on categorical axes to break ties. \code{method} is a parameter specifying which variables to use to break ties. The two implemented methods are \code{"from-left"} and \code{"from-right"}, meaning that ties are broken using a hierarchical ordering using variables' values from the left or the right, respectively. The parameter \code{space} specifies the amount of the `y` axis to use for space between levels of categorical variables. By default, 5\% of the axis is used for spacing.

\hh{XXX hierarchical ordering seems to minimize line crossings - but I don't have a proof. If we have a reference on ordering metrics this might go well here}

\autoref{fig:alignment} shows several approaches of dealing with categorical variables in parallel coordinate plots.
The left-most panel shows two categorical variables and the typical net of lines that forms between them in an original parallel coordinate plot. The other three panels show three different approaches of breaking the ties resulting from the categorical variables, with our favored solution shown on the right: all observations are spaced out evenly. This results in a natural visualization of the marginal frequencies along each axis (additionally enhanced by the lightly greyed boxes grouping observations in the same category). The ordering of the observations within the level is such that a minimal number of line crossings occurs between the axes. This method of dealing with categorical variables is the one we propose in the generalized parallel coordinate plot. While it is aesthetically pleasing, it also allows us in the
 spirit of the original parallel coordinate plots to follow an individual observation from left to right through the plot even for  categorical variables.
The other two solutions in the middle panels of \autoref{fig:alignment} show
two intermediary solutions of breaking ties in categorical variables: jittering and equi-spaced (unordered) values.
<<alignment, fig.height = 3.5, fig.align="center", fig.cap="Four different approaches of dealing with categorical variables: the panel on the left shows the typical net of lines resulting from categorical variables in regular parallel coordinate plots. In the other three panels ties in categorical levels are broken using different approaches: from left to right, jittering, equi-spaced line segments and ordered equi-spaced line segments are shown. ">>=
set.seed(20200924)
x1 <- c(rep(1, 5), rep(2, 3), rep(3, 4))
x2 <- c(1,2,1,2,1,1,1,1,2,2,2,1)
jitter1 <- runif(n = 12, min = -0.1, max = 0.1)
jitter2 <- runif(n = 12, min = -0.1, max = 0.1)
y <- c("a", "b", "c")[x1]
dfnew <- tibble(v1 = x2, v2 = x1,
                v3 = as.factor(x1),
                v4 = as.factor(x2),
                z = y,
                v5 = x2 + jitter1,
                v6 = x1 + jitter2,
                v7 = x2 + c(0, -0, 0.05, -0.05, 0.1, 0.15, 0.20, 0.25, -0.1, -0.15, -0.2, 0.3)/0.05*0.083,
                v8 = (x1-1)/2+1 + c(0:4*0.05, 0:2*0.05, 3:0*(-0.05))/0.05*0.083 + c(rep(0,5), rep(-0.04, 3), rep(0,4)))

p1 <- dfnew %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour = z), size=1) +
  theme_bw() +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) +
  xlab("") + ylab("") +
  facet_grid(.~"Original PCP") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none") +
  scale_x_discrete(expand = expansion(add=0.05))



p2 <- dfnew %>%
  mutate(v1 = v4, v2 = v3) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp_boxes(boxwidth=0.3, fill="grey90", alpha=0.5) +
  geom_pcp_axes() +
  geom_pcp(aes(colour = z), size=1) +
  theme_bw() +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) +
  xlab("") + ylab("") +
  facet_grid(.~"GPCP style") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none") +
  ylim(c(0,1))+
  scale_x_discrete(expand = expansion(add=0.2))



p3 <- dfnew %>%
  mutate(v1 = v5, v2 = v6) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(size=1, aes(colour = z)) +
  theme_bw() + ylab("") +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) + xlab("") +
  facet_grid(.~"Jitter") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none")+
  scale_x_discrete(expand = expansion(add=0.05))

p4 <- dfnew %>%
  mutate(v1 = v7, v2 = v8) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(size=1, aes(colour = z)) +
  theme_bw() + ylab("") +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) + xlab("") +
  facet_grid(.~"Equally spaced") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none")+
  scale_x_discrete(expand = expansion(add=0.05))

grid.arrange(p1, p3, p4, p2, nrow=1)
@

\subsection{Plotting Order of line segments}

\hh{XXX We need to include some code somewhere to also show the 'how'.}

\hh{XXX Order of levels and order of variables are important. } \au{Drawing pcps depends on what your goal might be.}


One of the primary advantages of the generalized approach to dealing with categorical variables is the ability to follow a single observation throughout the plot. As the number of observations increase, this becomes less feasible because of overplotting of line segments, particularly for slightly larger data sets. As more observations and line segments are drawn, more lines cross each other, increasing the effort required to follow a polyline from one side of the plot to the other. \hh{XXX the order in which crossing lines are drawn is only visible when the lines have different colors.}
As a countermeasure we carefully control the order in which line segments are plotted.

Two methods to control this order are implemented and are regulated by the parameter \code{overplot}:

\begin{enumerate}
%
\item \code{"small-on-top"} groups of lines (defined by the same color) between categorical variables are are ordered by size and drawn from largest to smallest group.
%
\item \code{"none"} the order of the observations is left un-touched by the data wrangling process. This option allows the user to specify a certain  order before plotting.
%
\end{enumerate}
\hh{additional counter-measures: use $\alpha$-blending}

\hh{the option of \code{"none"} is very flexible.}


\section{Examples}
\subsection{Palmers Penguins}

\hh{Several aspects in Parallel Coordinate Plots depend on orderings: order of variables along the $x$ axis, order of levels in a categorical variable, and order in which  lines are drawn.
Different orders emphasize different aspects of the data. Changing orders should therefore  (a) have good defaults, and (b) be easily changeable.}

\au{XXX
Drawing pcps depends on what your goal might be.  It reminds me of rotating plots and all the optimisation criteria that were suggested for a variety of purposes.  They did not necessarily work well, but they suggested some ways to proceed and generally improved things a bit.  What criteria might be similarly helpful for pcps?
}

\autoref{fig:ordering} shows a  generalized parallel coordinate plot of the Palmer penguins data \citep{penguins}. The data consists of body measurements, such as weight, flipper length, bill length, and depth,  of three species of penguins. What can be seen is that Adelie penguins generally have smaller bill lengths than the other two species, while Gentoo penguins can be distinguished from the other two species by their relatively larger flipper lengths.

\subsubsection{Distinguishing species}

<<prep-raw-penguin, warning = FALSE>>=
library(palmerpenguins)

p1 <- penguins_raw
p1 <- p1 %>% separate(col=`Individual ID`, into=c("Nest", "Individ"), remove=FALSE, sep=-2)
names(p1)[12:15] <- c("CulmenL", "CulmenD", "FlipperL", "BodyMass")
p1 <- p1 %>% separate(Species, into=c("species", "foo2", "foo3", "foo4"), sep=" ") %>% select(-starts_with("foo")) # foos make R happy, because it doesn't throw away anything unexpected
@


\autoref{fig:ordering} shows the effect of re-ordering the levels of both the `species` and the `island` variable in the generalized parallel coordinate plots.

<<ordering, fig.cap="Both of the levels of the island and the species variable re-ordered to reflect that two of the species are each only found on one island.", fig.height=6, fig.width=8>>=
library(scales)
#cols <- hue_pal()(3)
cols <- rev(c("#535993", "#C5D068", "#D4856A"))

# #####  Color Palette by Paletton.com
# #####  Palette URL: http://paletton.com/#uid=33W0V0kllllaFw0g0qFqFg0w0aF
#
#
# *** Primary color:
#
#    shade 0 = #323875 = rgb( 50, 56,117) = rgba( 50, 56,117,1) = rgb0(0.196,0.22,0.459)
#    shade 1 = #7D82B0 = rgb(125,130,176) = rgba(125,130,176,1) = rgb0(0.49,0.51,0.69)
#    shade 2 = #535993 = rgb( 83, 89,147) = rgba( 83, 89,147,1) = rgb0(0.325,0.349,0.576)
#    shade 3 = #191F58 = rgb( 25, 31, 88) = rgba( 25, 31, 88,1) = rgb0(0.098,0.122,0.345)
#    shade 4 = #080D3B = rgb(  8, 13, 59) = rgba(  8, 13, 59,1) = rgb0(0.031,0.051,0.231)
#
# *** Secondary color (1):
#
#    shade 0 = #9AA637 = rgb(154,166, 55) = rgba(154,166, 55,1) = rgb0(0.604,0.651,0.216)
#    shade 1 = #F1FAA6 = rgb(241,250,166) = rgba(241,250,166,1) = rgb0(0.945,0.98,0.651)
#    shade 2 = #C5D068 = rgb(197,208,104) = rgba(197,208,104,1) = rgb0(0.773,0.816,0.408)
#    shade 3 = #727D15 = rgb(114,125, 21) = rgba(114,125, 21,1) = rgb0(0.447,0.49,0.082)
#    shade 4 = #4A5300 = rgb( 74, 83,  0) = rgba( 74, 83,  0,1) = rgb0(0.29,0.325,0)
#
# *** Secondary color (2):
#
#    shade 0 = #AA5639 = rgb(170, 86, 57) = rgba(170, 86, 57,1) = rgb0(0.667,0.337,0.224)
#    shade 1 = #FFC0AA = rgb(255,192,170) = rgba(255,192,170,1) = rgb0(1,0.753,0.667)
#    shade 2 = #D4856A = rgb(212,133,106) = rgba(212,133,106,1) = rgb0(0.831,0.522,0.416)
#    shade 3 = #803015 = rgb(128, 48, 21) = rgba(128, 48, 21,1) = rgb0(0.502,0.188,0.082)
#    shade 4 = #551600 = rgb( 85, 22,  0) = rgba( 85, 22,  0,1) = rgb0(0.333,0.086,0)



# First pcp
pp1 <- p1 %>% pcp_select(studyName, species, Island, CulmenL:Sex) %>%
  pcp_scale() %>% pcp_arrange() %>% ggplot(aes_pcp()) +
  geom_pcp_axes(colour="white") +
  geom_pcp(aes(colour=species), alpha=0.8, overplot="none") +
  geom_pcp_boxes(fill="white", alpha = 0.5) +
  geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  ggtitle("Original order of levels and variables") +
  scale_colour_manual(values=c(cols[1], cols[2], cols[3]))

p1 <- p1 %>%   mutate(species=factor(species, levels=c("Chinstrap", "Adelie", "Gentoo"))) %>%
  mutate(island=factor(Island, levels=c("Dream", "Torgersen", "Biscoe")))


# Fourth pcp
pp2 <- p1 %>%
  pcp_select(studyName, species, island, CulmenL:Sex) %>%
#pp2 <- p1 %>% pcp_select(studyName, speciesC, islandC, CulmenL, `-CulmenD`, FlipperL:Sex) %>%
  pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour=species), alpha=0.8, overplot="none") +
  geom_pcp_boxes(fill="white", alpha = 0.5) +
  geom_pcp_labels(alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  scale_colour_manual(values=c(cols[2], cols[1], cols[3])) +
  ggtitle("Levels reordered to emphasize relationship between islands and species")

library(patchwork)
pp1 + pp2 + plot_layout(nrow = 2, byrow = FALSE)
@

The variables in \autoref{fig:penguins-variable-order} have been re-ordered
to allow the viewer to see what body measurements distinguish the species. Note that besides the re-ordering, the axes for Culmen depth is also reversed.
The plot shows that the Gentoo penguins are bigger, that Gentoo and Chinstrap are both only found on single islands, that Adelie and Chinstrap are distinguished by Culmen Length.
The plot does not show anything about the differences between male and female penguins.  Given the greater size of the males \au{we don't know that yet} in general it may be better to split by male and female, ignoring the missing values.  The results are the same for both sexes and stand out more.  Interestingly,  some potential outliers that were not visible previously, now stand out. \au{highlight the two Gentoo males with short flippers - ordering = 'none'}

\au{XXX Possible other ordering approaches would be to use some kind of association measure or a matrix reordering algorithm for two categorical variables, medians by category or R2 from a linear model for continuous and categorical, correlations for two continuous variables.}



<<penguins-variable-order, fig.cap="Changing the order of the variables along the x-axis emphasizes the differences in body measurements between the species.", fig.height=6, fig.width=8>>=
# Reorder the variables, moving CulmenL to the right, and do case ordering from the left
# Invert the CulmenD variable (and use the minus notation :-))
p1 <- p1 %>% mutate(`-CulmenD`=-CulmenD)

# Fifth pcp
# p1 %>% pcp_select(studyName, speciesC, islandC, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
#   pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
#   geom_pcp_axes(colour="white") +
#   geom_pcp(aes(colour=speciesC)) +
#   geom_pcp_boxes(fill="white") +
#   geom_pcp_labels(fill="white", alpha=1) +
#   xlab(NULL) + ylab(NULL) +
#   theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
#         legend.position="none") +
#   scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

# Change the order of printing the colours to make Chinstrap stand out better
# Requires rearranging of dataset case order and using overplot="none"
p1 <- p1 %>% arrange(fct_rev(species))

# # Sixth pcp
# p1 %>% pcp_select(studyName, speciesC, islandC, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
#   pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
#   geom_pcp_axes(colour="white") +
#   geom_pcp(aes(colour=speciesC), overplot="none") +
#   geom_pcp_boxes(fill="white") +
#   geom_pcp_labels(fill="white", alpha=1) +
#   xlab(NULL) + ylab(NULL) +
#   theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
#         legend.position="none") +
#   scale_colour_manual(values=c(cols[2], cols[1], cols[3]))
#



# Splitting by sex (not faceting so that NAs are excluded and scales are individual)
# Seventh pcp
m1 <- p1 %>% filter(Sex=="MALE") %>% pcp_select(studyName, species, island, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
geom_pcp_axes() +
geom_pcp(aes(colour=species), overplot="none", alpha = 0.8) +
geom_pcp_boxes(fill="white", alpha = 0.8) +
geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
xlab(NULL) + ylab(NULL) +
theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
legend.position="none") +
scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

f1 <- p1 %>% filter(Sex=="FEMALE") %>% pcp_select(studyName, species, island, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
geom_pcp_axes() +
geom_pcp(aes(colour=species), overplot="none", alpha = 0.8) +
geom_pcp_boxes(fill="white", alpha =0.8) +
geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
xlab(NULL) + ylab(NULL) +
theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
legend.position="none") +
scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

#library(patchwork)
#f1 + m1 + plot_layout(nrow = 2, byrow = FALSE)

p1 %>%
  filter(!is.na(Sex)) %>%
  pcp_select(studyName, species, island, `-CulmenD`, FlipperL, BodyMass, CulmenL) %>%
  group_by(Sex) %>%
  pcp_scale(.by_group = TRUE) %>%
  pcp_arrange(method="from-left", .by_group = TRUE) %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour=species), overplot="none", alpha = 0.8) +
  geom_pcp_boxes(fill="white", alpha =0.8) +
  geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  scale_colour_manual(values=c(cols[2], cols[1], cols[3])) +
  facet_grid(Sex~.)
@

\subsubsection{Determining sex}


%
<<penguins, fig.cap="Generalized Parallel Coordinate Plot of the Palmer penguins data.", fig.height=4, fig.width=8>>=
 penguins <- penguins %>%
   mutate(
     species = factor(species, c("Chinstrap", "Adelie", "Gentoo")),
     species2 = factor(species, c( "Adelie", "Gentoo","Chinstrap")),
     `-bill_length_mm`=-bill_length_mm,
     `-bill_depth_mm`=-bill_depth_mm
   )

penguins_pcp <- penguins %>%
    mutate(
        sex = ifelse(is.na(sex),"?", as.character(sex)),
        sex = factor(sex, levels = c("female", "?", "male"))
    ) %>%
  filter(!is.na(body_mass_g)) %>%
  pcp_select(species2,`bill_length_mm`,
             flipper_length_mm, body_mass_g, `-bill_depth_mm`, species,  sex) %>%
  pcp_scale() %>%
  pcp_arrange()

penguins_pcp %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes(boxwidth=0.1) +
  geom_pcp(aes(colour = sex), alpha = 0.8) +
  geom_pcp(aes(colour = sex), size =1,
           data = penguins_pcp %>% filter(sex=="?")) +
  geom_pcp_labels(aes(label = pcp_level), alpha = .75) +
  theme_bw() +
  scale_colour_manual(values=c("#FFCD70", "#8b4950", "#008080")) +
#    scale_colour_manual(values=c("#ff595e", "#573e79", "#1982c4")) +
  theme(legend.position="bottom") +
  ylab("") +
  xlab("") #+
#  facet_wrap(~sex)
@


\hh{XXX intro to ... now we are shifting focus to draw generalized pcps to determine sex. }

The lines in \autoref{fig:penguins} are colored by sex of penguins. What can be seen is that within each species, the males tend to be larger in size and heavier than the females. For several of the penguins, sex could not be determined because either the sexing primer did not amplify or no blood sample was obtained \citep{penguins2}. These penguins are represented by dark lines.  Based on these penguins' body measurements within the context of the other penguins, we can make some suggestions regarding their sex. \hh{\autoref{fig:penguins2b} shows another version of a generalized parallel coordinate plot: ribbons of inter-quantile ranges are plotted across body measurements. We facet by species and sex. The two ribbons shown represent the interquartile range (middle 50\% of the data) and the range between the 2.5\% and the 97.5\% quantiles (inner 95\%). These ribbons provide a basic summary of the each variable and its two dimensional density with each of its adjacent axes.
Body measurements of the unsexed animals are represented as line segments on top. facetted version of the previous generalized parallel coordinate plots.
 While we facet both by species and sex, note that the axes are re-scaled within each species  to make use of the full range in $y$. However, we use the same scale between the two sexes of each species. This different treatment of facetting variables is achieved by the use of the grouping variable.  The listing in  \autoref{fig:penguins2a} shows the code for prepping the data shown in \autoref{fig:penguins2b}. By grouping on species but not on sex (see line 9), data is being rescaled within species but the same scaling is used across males and females. Measurements for unsexed animals are shown as line segments on top of the interquantile-ribbons of both sexes. Viewers are encouraged to draw a conclusion about an animal's sex based on their values within the (2d density) context of their species and hypothetical sex. Statistically, this comparison relates to a likelihood ratio test: the viewer is asked to make an assessment of the likelihood to observe the measurements of an animal under each of the two competing hypotheses of sex.}


%\caption{Code for prepping data for \autoref{fig:penguins2b}: \caption{fig:penguins2a}}
<<penguins2a, echo=TRUE, reset=TRUE>>=
penguins_pcp <- penguins %>%
    filter(species != "Chinstrap") %>%                   # no unsexed animals in Chinstrap
    mutate(
        sex = ifelse(is.na(sex),"?", as.character(sex)), # make assignment more readable
        sex = factor(sex, levels = c("female", "?", "male"))
    ) %>%
  filter(!is.na(body_mass_g)) %>%
  pcp_select( 4:3, 5:6) %>%
  group_by(species) %>%                                  # re-scale by species
  pcp_scale() %>%
  pcp_arrange()
@

Chinstrap penguins are excluded (line 2) because all of their individuals in the data have a sex assigned.
The general pattern of measurements of the Gentoo penguins suggests that three of the four individuals with missing sex information are female (the three with the lowest bill depth). The fourth animal has an exceptionally deep bill, however, all other measurements suggest that this animal, too, is female. For further evidence, we find from the original data  that their nest partners are all sexed as male. While assuming that nest partners are male and female is not a perfect method, in particular, for penguins, which have been shown to live in same-sex partnerships, in  all three of the studies considered for this data only nests with breeding successes have been considered. More details can be found in \citet{penguins2b}.
For Adelie penguins the situation is not quite as clear-cut, but based on body mass and bill length measurements the three lightest penguins might be female, while the heaviest one could be male. The fifth penguin \hh{literally? I need to re-phrase this sentence} walks the line between typical male and typical female measurements. \hh{Trying to confirm the putative assignments is a bit more tricky for these penguins, because four of the five unsexed penguins are nest partners. The lightest unsexed penguin is the partner of a sexed male penguin. The putative assignments do not contradict the hypothesis that each nest is host to a male and a female penguin. Using this assumption, the last unsexed penguin would be resolved as  the male of the nest.  }


%\caption{\label{penguin2-code} Code for prepping the data for figure penguin2}
%Code for prepping the data shown in \autoref{fig:penguins2b}:



<<penguins2b, dependson="penguins2a", fig.cap="Closer investigation of non-sexed Adelie and Gentoo penguins. The group\\_by call before pcp\\_scale is responsible for scaling by species while the same scale is kept across sex within species. Penguins without assigned sex (based on blood markers) are drawn on top of both sexes. \\hh{The labels to the right of the ribbons are our best guess at a penguin's sex based on body measurements of other penguins of the same species. The markers on the right indicate four unsexed penguins that are nest partners. }", fig.height = 6, fig.width = 8>>=

# making ribbons
# probs <- seq(0,1,by=0.1)
probs <- c(0.025, 0.25, 0.75, 0.975)

dframe <-
  penguins_pcp %>% filter(sex!="?") %>% group_by(species, sex, pcp_x) %>%
  summarise(value = quantile(pcp_y, prob=probs),
            quantile=probs,
            lower = probs<0.5,
            level = round(10*abs(quantile-0.5), digits = 1))  %>%
  select(-quantile) %>%
  mutate(lower = factor(lower, labels=c("upper", "lower"))) %>%
  pivot_wider(names_from="lower", values_from="value") %>%
  ungroup() %>%
  mutate(
    level = ifelse(level > 2.5, "Inner 95%", "Inner 50%"),
    level = factor(level, levels=c("Inner 50%", "Inner 95%"))
  ) # %>% filter(level <= 4)

# for annotations
annotate_dframe <- penguins_pcp %>%
  filter(sex=="?", !is.na(body_mass_g), pcp_x == "body_mass_g")

library(emojifont)
load.fontawesome()
labels <- fontawesome(c('fa-venus','fa-mars', "fa-question"))

annotate_dframe$putative <- labels[1]
annotate_dframe <- annotate_dframe %>% mutate(
  putative = ifelse(pcp_y > 0.4, labels[3], putative),
  putative = ifelse(pcp_y > 0.5, labels[2], putative)
)

circle <- fontawesome(c( 'fa-star', 'fa-github'))

# recalculate position by group
# XXXX pcp_arrange has to also do the tie-breaking by group.
penguins_pcp %>%
  filter(sex!= "?") %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes(boxwidth=0.1) +
#  geom_pcp(aes(colour = sex), alpha = 0.4) +
  geom_ribbon(aes( ymin = lower, ymax=upper, group=interaction(sex,level), fill = sex, alpha=level),
              #alpha = 0.25,
              data = dframe) +
  geom_pcp(aes(colour = sex, fill = "?"), colour = "#8b4950dd", size = 0.9,
           data = penguins_pcp %>% filter(sex=="?") %>% mutate(sex = "female")) +
  geom_pcp(aes(colour = sex, fill = "?"), colour = "#8b4950dd", size = 0.9,
           data = penguins_pcp %>% filter(sex=="?") %>% mutate(sex = "male")) +
  geom_pcp_labels(aes(label = pcp_level), alpha = .5) +
  theme_bw() +
  scale_fill_manual(values=c( "#8b4950", "#FAA404", "#008080")) + # lighter yellow "#FFCD70"
  theme(legend.position="bottom") +
    facet_grid(species~sex) +
  scale_x_discrete(expand = expansion(add=0.25)) +
  xlab("") + ylab("") +
  scale_alpha_manual("Inter-quantile Range", values = c(0.25, 0.25)) +
  guides(
    fill = guide_legend(override.aes = list(alpha = 0.5)),
    alpha = guide_legend(override.aes = list(alpha =  c(0.5, 0.25)))
  ) +
  geom_text(aes(colour = sex, label=putative), colour = "#8b4950",
           data = annotate_dframe %>% mutate(sex = "male"), nudge_x = 0.125,
           family='fontawesome-webfont', size=5) +
  geom_text(aes(colour = sex, label=putative), colour = "#8b4950",
           data = annotate_dframe %>% mutate(sex = "female"), nudge_x = 0.125,
           family='fontawesome-webfont', size=5) +
  geom_text(aes(label=marker),
            data = data.frame(
                 species="Adelie",
                 marker = c(circle[1], circle[1], circle[2], circle[2]),
                              pcp_y = c(0.783, 0.433, 0.3, 0.267),
                              pcp_x = "bill_depth_mm",
                 nest = c("N5", "N5", "N6", "N6")),
            colour = "#8b4950",
           nudge_x = -0.1,
           family='fontawesome-webfont', size=3)

@


\subsection{Getting a second, third, ... and seventh opinion}\label{sec:carcinoma}

\autoref{fig:carcinoma} shows data from \citet{agresti} published as part of the \code{poLCA} package \citep{polca}. Seven pathologists were asked to assess the same 118 slides for the presence or absence of carcinoma in the uterine cervix. Binary responses for each slide were recorded (yes/no).  Pathologists all agreed on about 25\% of slides, which they  considered to be carcinoma free, and a further 12.5\% of slides, which were considered to show carcinoma by all pathologists.
For the remaining 62.5\% of slides there was some disagreement. However, we see that this disagreement is not random. When pathologists are ordered (by moving the corresponding axes) left to right from fewest number of overall carcinoma diagnoses to highest number, we see that generally for a slide more pathologists make a carcinoma diagnosis  from left to right.
<<carcinoma, fig.cap="Pathologists' diagnoses of absence (no) or presence (yes) of carcinoma in the uterine cervix based on 118 slides. Each slide is shown by a polyline.", fig.height = 4, fig.width = 8>>=
data("carcinoma", package = "poLCA")
carcinoma$numdiag <- rowSums(carcinoma) - 7
carcinoma$any <- carcinoma$numdiag > 0

carcinoma[,1:7] <- carcinoma[,1:7] %>%
  purrr::map(.f = function(x) factor(x, labels =c("no", "yes"))) %>%
  data.frame()

carcinoma %>%
  pcp_select(6,4,3,1,7,5,2) %>%
  pcp_scale(method="raw") %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
    geom_pcp_axes() +
    geom_pcp_boxes() +
    geom_pcp(aes(colour = factor(numdiag))) +
    geom_pcp_labels(aes(label = pcp_level), alpha = .5) +
    scale_colour_brewer("Number of\ncarcinoma\ndiagnoses", palette ="Dark2") +
    theme_bw() +
    guides(color = guide_legend(reverse=TRUE, override.aes = list(size = 3))) +
  scale_x_discrete(expand = expansion(add=0.25)) +
  xlab("") +
  ylab("")
@

\hh{note: in this example we do not need to scale the variables. Aside from the actual scale the values are ordered in the same way. }

%------------------------------------------------

\subsection{Clustering with PCPs}

Let's revisit the penguins data for an example of working with clusters in the framework of generalized parallel coordinate plots. We use $k$-means clustering on all numeric body measurements and investigate which observations are generally captured in each of the clusters.

\svp{Because $k$-means clustering assigns cluster labels arbitrarily based on random cluster centers, in order to maintain a persistent ordering over different values of $k$ we reorder the clusters by the value of \code{body\_mass\_g}. This allows us to compare between e.g. $k$ and $k+1$ clusters.}

\svp{\autoref{fig:kmean-penguins} shows the numeric measurements along with the assigned clusters, with categorical variables sex and species on the right. Each line is colored by the assigned cluster, allowing us to determine how the categorical variables relate to the quantitative variables and the resulting clusters.}

\svp{When $k=2$, \autoref{fig:penguink2} shows that the largest difference in the observed data is between Gentoo penguins and the other two species. When $k=3$, in \autoref{fig:penguink3}, the additional cluster separates the Adelie and Chinstrap penguins into two groups with a few misclassifications; this additional cluster is based on the length of the bill (which we can follow due to the clear connection between data values in the generalized PCP). Adding a fourth cluster, as in \autoref{fig:penguink4} splits Adelie penguins into males and females, though again there are again some penguins who are misclassified. The addition of a fifth cluster in \autoref{fig:penguink5} splits Chinstrap penguins into male and female. Once we add a sixth cluster in \autoref{fig:penguink6}, we finally split the Gentoo penguins by sex as well, though again this clustering is not perfect.}

\svp{What is clear from this exercise is that Adelie and Chinstrap penguins are much more similar to each other than they are to Gentoo penguins, but that there is still noticable sexual dimorphism within each species. \autoref{fig:cl-overview} shows the changes between successive clusters and the corresponding species and sex classification for each observation.}


<<cluster-setup>>=
penguins_complete <- penguins %>% na.omit()

# run kmeans for k from 2 to 8, sort clusters by body weight,
# then label clusters from lightest to heaviest
set.seed(20220901)
clusters <- tibble(k = 2:8)
clusters <- clusters %>% mutate(
  kmeans_cl = k %>% purrr::map(.f = function(cl) {
    kmeans(penguins_complete %>%
             select(bill_length_mm:body_mass_g) %>%
             mutate(
               across(.fns = scale)
             ), centers=cl)
  })
)

penguins_complete$cl2 <- clusters$kmeans_cl[[1]]$cluster
penguins_complete$cl3 <- clusters$kmeans_cl[[2]]$cluster
penguins_complete$cl4 <- clusters$kmeans_cl[[3]]$cluster
penguins_complete$cl5 <- clusters$kmeans_cl[[4]]$cluster
penguins_complete$cl6 <- clusters$kmeans_cl[[5]]$cluster
penguins_complete$cl7 <- clusters$kmeans_cl[[6]]$cluster
penguins_complete$cl8 <- clusters$kmeans_cl[[7]]$cluster

penguins_complete <- penguins_complete %>% mutate(
  across(starts_with("cl"), as.factor),
  across(starts_with("cl"), .fns = function(cl) {
    cl <- reorder(cl, body_mass_g, mean)
    levels(cl) <- 1:length(levels(cl))
    cl
  })
)

# penguins_complete <- penguins_complete %>% mutate(
#   species = factor(species, levels = c("Gentoo", "Adelie", "Chinstrap"))
# )
@

<<cl2, fig.cap="Parallel coordinate plot of penguins' body measurements (left), a separation into two clusters, and penguins' species (right). There is a strong pattern between bill depth and flipper length that separates Gentoo penguins from the perfectly from the other two species.", fig.height = 4, fig.width = 8, include = F>>=
penguins_complete %>%
  mutate(
    cl2 = reorder(cl2, body_mass_g, mean)
  ) %>%
  pcp_select(bill_length_mm:body_mass_g, cl2, species) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(color=cl2), alpha = 0.8) +
  geom_pcp_boxes(fill=NA) +
  geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete("",expand = expansion(add=0.25),
                   labels=c("Bill length", "Bill depth",
                            "Flipper length", "Body mass",
                            "k=2 Clusters", "Species")) +
  ggtitle("Clustering into 2 groups")

@

<<cl3, fig.cap="The third cluster splits the former second cluster into two based on the length of the bill. The three species are almost perfectly separated in using three clusters.", fig.height = 4, fig.width = 8, include = F>>=
penguins_complete %>%
  mutate(
    cl3 = reorder(cl3, body_mass_g, mean)
  ) %>%
  pcp_select(bill_length_mm:body_mass_g, cl3, species) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(color=cl3), alpha = 0.8) +
  geom_pcp_boxes(fill=NA) +
  geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete("",expand = expansion(add=0.25),
                   labels=c("Bill length", "Bill depth",
                            "Flipper length", "Body mass",
                            "k=3 Clusters", "Species")) +
  ggtitle("Clustering into 3 groups")

@


<<cl4, fig.cap="The fourth cluster splits Adelie penguins (mostly) into males and females of the species.", fig.height = 4, fig.width = 8, include = F>>=
penguins_complete %>%
  mutate(
    cl4 = reorder(cl4, body_mass_g, mean)
  ) %>%
  pcp_select(bill_length_mm:body_mass_g, cl4, species, sex) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(color=cl4), alpha = 0.8) +
  geom_pcp_boxes(fill=NA) +
  geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete("",expand = expansion(add=0.25),
                   labels=c("Bill length", "Bill depth",
                            "Flipper length", "Body mass",
                            "k=4 Clusters", "Species")) +
  ggtitle("Clustering into 4 groups")

@

<<cl5, fig.cap="The fifth cluster splits the group of Chinstrap penguins (mostly) into females and males. Only a handful of individual penguins are grouped with the wrong species or tge wrong sex. One Chinstrap male from cluster 2 is grouped with females. This might  be an example of a 'femboy' (males that appear phenotypically like females) known in the penguin research literature \\hh{XXX cite!}", fig.height = 4, fig.width = 8, include = F>>=
penguins_complete %>%
  mutate(
    cl5 = reorder(cl5, body_mass_g, mean)
  ) %>%
  pcp_select(bill_length_mm:body_mass_g, cl5, species, sex) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(color=cl5), alpha = 0.8) +
  geom_pcp_boxes(fill=NA) +
  geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete("",expand = expansion(add=0.25),
                   labels=c("Bill length", "Bill depth",
                            "Flipper length", "Body mass",
                            "k=5 Clusters", "Species")) +
  ggtitle("Clustering into 5 groups")

@

<<cl6, fig.cap="The sixth cluster does...", fig.height = 4, fig.width = 8, include = F>>=
penguins_complete %>%
  mutate(
    cl6 = reorder(cl6, body_mass_g, mean)
  ) %>%
  pcp_select(bill_length_mm:body_mass_g, cl6, species, sex) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(color=cl6), alpha = 0.8) +
  geom_pcp_boxes(fill=NA) +
  geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete("",expand = expansion(add=0.25),
                   labels=c("Bill length", "Bill depth",
                            "Flipper length", "Body mass",
                            "k=5 Clusters", "Species")) +
  ggtitle("Clustering into 6 groups")
@


% \autoref{fig:cl2} shows a parallel coordinate plot relating the separation of body measurements into two main groups to each measurement variable and the three species.
\begin{figure}
     \centering
     \begin{subfigure}[b]{.8\textwidth}
         \centering
         \includegraphics[keepaspectratio=true,width=\linewidth]{figures/cl2-1}
         \caption{When $k=2$, Gentoo penguins are separated from Adele and Chinstrap penguins.}
         \label{fig:penguink2}
     \end{subfigure}
\\
     \begin{subfigure}[t]{0.48\textwidth}
         \centering
         \includegraphics[keepaspectratio=true,width=\linewidth]{figures/cl3-1}
         \caption{The third cluster splits the former second cluster into two based on the length of the bill. The three species are almost perfectly separated in using three clusters.}
         \label{fig:penguink3}
     \end{subfigure}
\hfill
     \begin{subfigure}[t]{0.48\textwidth}
         \centering
         \includegraphics[keepaspectratio=true,width=\linewidth]{figures/cl4-1}
         \caption{The fourth cluster splits Adelie penguins (mostly) into males and females of the species.}
         \label{fig:penguink4}
     \end{subfigure}
\\
     \begin{subfigure}[t]{0.48\textwidth}
         \centering
         \includegraphics[keepaspectratio=true,width=\linewidth]{figures/cl5-1}
         \caption{The fifth cluster splits the group of Chinstrap penguins (mostly) into females and males. Only a handful of individual penguins are grouped with the wrong species or the wrong sex.}
         \label{fig:penguink5}
     \end{subfigure}
\hfill
     \begin{subfigure}[t]{0.48\textwidth}
         \centering
         \includegraphics[keepaspectratio=true,width=\linewidth]{figures/cl6-1}
         \caption{With the introduction of a sixth cluster, Gentoo penguins are split into males and females. However, the sex separation for Chinstrap penguins gets lost in this clustering. }
         \label{fig:penguink6}
     \end{subfigure}
        \caption{An overview of the use of parallel coordinate plots to examine which variables contribute to clustering and to identify individuals who are misclassified.}
        \label{fig:kmean-penguins}
\end{figure}

<<cl-overview-2, fig.cap="Overview of all clusters for $k$=2 to 6.", fig.height = 4, fig.width = 8>>=
set.seed(20220901)
clusters6 <- tibble(k = rep(6, 7))
clusters6 <- clusters6 %>% mutate(
  kmeans_cl = k %>% purrr::map(.f = function(cl) {
    kmeans(penguins_complete %>%
             select(bill_length_mm:body_mass_g) %>%
             mutate(
               across(.fns = scale)
             ), centers=cl)
  })
)

penguins_complete$cl6b <- clusters6$kmeans_cl[[1]]$cluster
penguins_complete$cl6c <- clusters6$kmeans_cl[[2]]$cluster
penguins_complete$cl6d <- clusters6$kmeans_cl[[3]]$cluster
penguins_complete$cl6e <- clusters6$kmeans_cl[[4]]$cluster
penguins_complete$cl6f <- clusters6$kmeans_cl[[5]]$cluster
penguins_complete$cl6g <- clusters6$kmeans_cl[[6]]$cluster
penguins_complete$cl6h <- clusters6$kmeans_cl[[7]]$cluster

penguins_complete <- penguins_complete %>% mutate(
  across(starts_with("cl6"), as.factor),
  across(starts_with("cl6"), .fns = function(cl) {
    cl <- reorder(cl, as.numeric(species:sex), mean)
    levels(cl) <- 1:length(levels(cl))
    cl
  })
)

penguins_complete %>%
  pcp_select(starts_with("cl6"), species, sex) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
    geom_pcp(aes(color=interaction(sex, species)), alpha = 0.6) +
    geom_pcp_boxes(fill=NA, colour = "black", size = .5) +
    geom_pcp_labels(alpha = 0.9) +
  theme_bw() +
  scale_color_brewer(type="qual", palette = "Paired") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  # scale_y_continuous(labels=c("low", "", "medium", "", "high"),
  #                    breaks=c(0,0.25, .5,.75, 1)) +
  scale_y_continuous(breaks = NULL) +
  scale_x_discrete("",expand = expansion(add=0.5))

@

<<cl-overview, eval=FALSE, fig.cap="Overview of all clusters for $k$=2 to 6.", fig.height = 4, fig.width = 8>>=
penguins_complete %>%
    mutate(
    across(starts_with("cl"), .fns = function(x) reorder(x, body_mass_g, mean))
  ) %>%
  select(-c(cl7, cl8)) %>%
  pcp_select(starts_with("cl"), species, sex) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
    geom_pcp(aes(color=interaction(sex, species)), alpha = 0.6) +
    geom_pcp_boxes(fill=NA) +
    geom_pcp_labels() +
  theme_bw() +
  scale_color_brewer(type="qual", palette = "Paired") +
  theme(legend.position = "none") +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  # scale_y_continuous(labels=c("low", "", "medium", "", "high"),
  #                    breaks=c(0,0.25, .5,.75, 1)) +
  scale_y_continuous(breaks = NULL) +
  scale_x_discrete("",expand = expansion(add=0.25))

@


\section{Discussion}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------


\bibliography{refs.bib}

%----------------------------------------------------------------------------------------
\begin{appendix}
\section{Example usage}
Commented code for \autoref{fig:carcinoma}:
<<code-figure, eval=FALSE, echo=TRUE>>=
data(carcinoma, package = "poLCA")

# Prepping the Dataset
carcinoma$total <- rowSums(carcinoma) - 7
carcinoma <- carcinoma %>% mutate(
  across(A:G, .fns = as.factor)
)

carcinoma %>%

# Selecting and scaling variables
pcp_select(F, D, C, A, G, E, B, tot) %>%
pcp_scale(method="uniminmax") %>%
pcp_arrange() %>%

# Setting up ggplot for pcp and setting pcp display options
ggplot(aes_pcp()) +
geom_pcp_axes() +
geom_pcp_boxes(colour="black", alpha=0) +
geom_pcp(aes(colour = tot)) +
geom_pcp_labels(aes(label = pcp_level), fill="white", alpha = 1) +

# Choosing general ggplot display options
scale_colour_brewer("Number of\ncarcinoma\ndiagnoses", palette ="Dark2") +
theme_bw() +
guides(color = guide_legend(reverse=TRUE, override.aes = list(size = 5))) +
scale_x_discrete(expand = expansion(add=0.25)) +
xlab(NULL) + ylab(NULL) +
theme(axis.text.y=element_blank(), axis.ticks.y=element_blank())
@
\end{appendix}

\end{document}

