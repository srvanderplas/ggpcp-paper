%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath,amssymb,array}

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[margin=1in,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{subfig} % Sub figures
\usepackage{graphicx} % better graphics
\usepackage{float}
\usepackage[dvipsnames]{xcolor} % colors

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{nameref} % \Cref command automatically handles figure/table/etc refs

\usepackage{natbib}
\bibliographystyle{abbrvnat}

% Commands for editing
\newcommand{\hh}[1]{{\textcolor{orange}{#1}}}
\newcommand{\svp}[1]{{\textcolor{blue}{#1}}}
\newcommand{\au}[1]{{\textcolor{ForestGreen}{#1}}}

\newcommand{\code}[1]{\texttt{{#1}}}
\newcommand{\pkg}[1]{\texttt{{#1}}}
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{A grammar of graphics framework for generalized parallel coordinate plots} % Article title
\author{%
\textsc{Author 1}$^1$\thanks{Corresponding author: \href{mailto:xxx}{xxx}}\hspace{2em}
\textsc{Author 2}$^2$\hspace{2em}
\textsc{Author 3}$^3$\\[1ex] % Your name
{\footnotesize
$^1$ University 1;
$^2$ University 2;
$^3$ University 3
} %
}
\date{\today} % Leave empty to omit a date

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle
\begin{abstract}
\noindent Parallel coordinate plots (PCP) are a useful tool in exploratory data analysis of high-dimensional numerical data. The use of PCPs is limited when working with categorical variables or a mix of categorical and continuous  variables. In this paper, we propose generalized parallel coordinate plots (GPCP) to extend the ability of PCPs from just numeric variables to dealing seamlessly with a mix of categorical and numeric variables in a single plot. In this process we find that existing solutions for categorical values only, such as hammock plots or parsets become edge cases in the new framework. By focusing on individual observations rather than a marginal frequency we gain additional flexibility. The resulting approach is implemented in the R package ggpcp.
% Dummy abstract text - replace \blindtext with your abstract text
\end{abstract}
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

<<setup, echo=FALSE, warning=FALSE, message=FALSE>>=
library(knitr)
knitr::opts_chunk$set(fig.path="figures/", echo=FALSE, out.width = '\\linewidth', warning=FALSE, message=FALSE, cache = TRUE)
@

<<packages, echo=FALSE, warning=FALSE, message=FALSE>>=
library(tidyverse)
library(ggpcp)
library(gridExtra)

theme_set(theme_bw())
@

\section{Introduction}

Few approaches in data visualization exist that are truly high-dimensional. Most visualizations are projections of data into two or three dimensions enhanced by additional mappings to plot aesthetics, such as point size and color, or facetting.
Parallel coordinate plots are one of the exceptions: in parallel coordinate plots we can actually visualize an arbitrary many number of variables to get a visual summary of a high-dimensional data set. In a parallel coordinate plot each variable takes the role of a vertical (or parallel) axis; giving the visualization its name. Multivariate observations are then plotted by connecting their respective values on each axis across all axes using polylines (cf. \autoref{fig:sketch}). For just two variables this switch from orthogonal axes to parallel axes is equivalent to a switch from the familiar Euclidean geometry to the Projective Space. In the projective space, points take the role of lines, while lines are replaced by points, i.e. points falling on a line in the Euclidean space correspond to lines crossing in a single point in the Projective Space.  This duality provides a good basis for interpreting geometric features observed in a parallel coordinate plot \citep{Inselberg:1985}.


The origins of parallel coordinate plots date back to the 19th century and are, depending on the source, either attributed to  \citet{dOcagne:1885} or  \citet{Gannett:1880}.
Modern era parallel coordinate plots go back to  \citet{Inselberg:1985} and \citet{Wegman:1990}. Parallel coordinate plots are used in an exploratory setting as a way to get a high-level overview of the marginal distributions involved, to identify outliers in the data and to find potential clusters of points. In the absence of those, Parallel Coordinate Plots are often critized for the amount of clutter they produce, resembling a game of mikado rather than organized data.
This clutter is sometimes combatted by the use of $\alpha$-blending \citep{alpha-blending}, density estimation \citep{density-pcp}, or edge-bundling parallel coordinate plots \citep{edge-bundling}. For a detailed overview of these and other techniques see \citet{review}.

However, parallel coordinate plots have some shortcomings. \hh{XXXX after bashing clutter in pcps, `some shortcomings' feels like rubbing it in :)} The biggest challenge comes when working with categorical variables. In current solutions, levels of categorical variables are transformed to numbers and variables are then used as if they were numeric. This introduces a lot of ties into the data, and the resulting parallel coordinate plot becomes uninformative, as it only shows lines from each level of one variable to all levels of the next variable.
Some versions of parallel coordinate plots have been  specifically developed to deal with categorical data, e.g. parallel set plots \citep{Kosara:2006}, Hammock plots \citep{Schonlau:2003}, and common angle plots \citep{Hofmann:2013}. These solutions all have in common that they work with tabularized data and show bands of observations from one categorical variable to the next. Hammock plots and common angle plots provide solutions to mitigate the sine-illusion's effects \citep{sine, susan:2015} on  parallel sets plots.
An attempt to combine categorical and numeric variables in a parallel coordinate plot is introduced in the categorical parallel coordinate plots of \citet{cpcp}. These plots provide an extension to parallel sets that allows numeric variables to be included in the plot. Similar to parallel sets, this approach is also based on marginal frequencies for the categorical variables. Categorical parallel coordinate plots are the closest of these variations to our solution,  but they are not implemented in the \pkg{ggplot2} framework and can therefore not be further extended.


Various packages in R \citep{R} exist that contain an implementation of one of the parallel coordinate plots. The function "parcoord" in the \pkg{MASS} package \citep{MASS} makes use of the base plot system of R to draw parallel coordinate plots.
The function "cpcp" in package \pkg{iplots} implements the parallel coordinate plot \citep{cpcp}. Developments based on the grammar of graphics \citep{wilkinson:1999} and the \pkg{ggplot2} \citep{ggplot2} framework are, e.g. the function `ggparcoord' in \pkg{GGally} \citep{GGally} or \pkg{ggparallel} \citep{ggparallel} which provide an implementation of Hammock and common-angle plots.

Those packages based on \pkg{ggplot2} make use of \pkg{ggplot2}, but are actually wrapper of existing functions for highly specialized plots with tens of parameters, which do not allow the full flexibility of \pkg{ggplot2} and do not make use of \pkg{ggplot2}'s  layer framework.

<<sketch, warning=FALSE, results='asis', fig.width = 9, fig.height = 3, fig.cap="Sketch of a parallel coordinate plot of two observations in four dimensions. Each dimension is shown as a vertical axis, observations are connected by polylines from one axis to the next. ">>=
df <- data.frame(x1 = c(1,2), x2 = c(0, 0.5), x3=c(2,1), x4=c(2,3), id=c(1,2))
df %>%
  pcp_select(x1:x4) %>%
#  mutate(value = parse_number(as.character(value))) %>%
  pcp_scale(method="globalminmax") %>%
  ggplot(aes_pcp())  +
  geom_pcp_axes() +
  geom_pcp(aes(colour = factor(pcp_id)), size=1) +
  geom_point(aes(shape=factor(pcp_id), colour = factor(pcp_id)), size=5) +
  theme_bw() +
  xlab("Variables") +
  scale_shape_discrete("Observation") +
  scale_colour_manual("Observation", values=c("darkorange", "purple4")) +
  ylab("") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  scale_y_continuous(labels=c("low", "", "medium", "", "high"),
                     breaks=c(0,0.25, .5,.75, 1)) +
  scale_x_discrete(expand = expansion(add=0.2))
@


The remainder of the paper is organized as follows: \autoref{sec:wrangling} describes the data processing for parallel coordinate plots.

% Section 3  presents the conceptual framework of  generalized parallel coordinate plots and general principles informing their construction. Section 4 describes the connection between generalized parallel coordinates and the grammar of graphics. Section 5 provides three examples highlighting different aspects of the use of  generalized parallel coordinate plots in an exploratory setting.

%------------------------------------------------

\section{Data management}\label{sec:wrangling}
%------------------------------------------------

The idea behind this re-implementation of parallel coordinate plots is to expose parallel coordinate plots at a functional level. Rather than using a single function with parameters controlling every aspect, we separate the data management from the visual rendering.
\hh{In particular, we separate out the data management into three parts:}
\begin{enumerate}
\item Variable selection and reshaping data,
\item Scaling of axes, both at the individual level and in the relationship of the axes to each other, and
\item Treatment of ties in categorical axes. \hh{The treatment of ties is an aspect not generally addressed in the original parallel coordinate plots of \citet{Inselberg:1985} and \citet{Wegman:1990}. We have found a need to deal with ties, because ties are visually the main obstacle of allowing the viewer to follow an observation from axis to axis through the high-dimensional space. Once this assessment is broken for the individual observation, the  we cannot reasonably expect to gain much more information by plotting more data in the plot. XXX this is clumsy - what I am really aiming for needs a bit more: the way plots should be used in order to make sense of complicated situations is  to provide (1) a visual summary of the main trends and (2) allow us to identify observations that do not follow those trends. By mapping all plots that have the same value on one dimension into a single point on an axis, we hinder any higher-dimensional insights.}
\end{enumerate}

\au{XXX test test}

\hh{The modularization of the data wrangling process has the additional advantage to lay out the necessary elements in successive steps. Some of these steps are even optional - e.g. scaling variables might not be necessary, if all variables are already on the same scale (i.e. method `raw` in GGally); similarly, using pcp\_arrange to break ties is only necessary if there are any factor variables, and if we actively want to spread these observations out. }



\subsection{Variable selection}

One of the biggest strengths of the Grammar of Graphics is its mapping between data variables and visual aesthetics.
In standard plots any mapping is a function between one aesthetic and one data variable.
In a parallel coordinate plot, this one-to-one mapping between data and plot aesthetics is seemingly turned into a one-to-many mapping between arbitrarily many data variables to the x axis . However, by transforming the wide form of the data set into a long form \citep{reshape, dplyr, jss.tidy, hadley.tidy}, we get to a form of the dataset in which we achieve a one-to-one mapping to a now discrete x axis consisting of the (names of the) original data variables.

\hh{From the user's perspective this data reshaping has purely the form of a data selection, while the data wrangling is going on behind the scenes in this function.}

\code{pcp\_select(data, ...)} allows a selection of variables to be included in the parallel coordinate plot.
Variables can be specified by

\begin{itemize}
\item position, e.g. \code{1:4, 7, 5, 4},
\item name, e.g. \code{class, age, sex, aede1:aede3} or
\item using pattern selectors, e.g. \code{starts\_with("aede")}, see \code{?tidyselect::select\_helpers}
\end{itemize}

or any combination thereof. Variables can be selected multiple times and will then be included in the data and the resulting plot multiple times.
The order in which variables are selected determines the order in which the corresponding axis is drawn in the parallel coordinate plots.
\code{pcp\_select} transforms the selected variables to long form and embellishes the data set with a number of additional variables. All of the newly created and added variables start with the prefix \code{pcp\_}:
\begin{itemize}
\item \code{pcp\_x}: discrete variable consisting of the names of the selected variables in the order that they were selected - this is the order in which the variables will be included in the plot.
\item \code{pcp\_y}: numeric variable containing the values of all of the selected variables. In case a selected variable is not numeric, it is converted to a factor variable and the (numeric) factor levels are saved in \code{pcp\_y}.
\item \code{pcp\_level}: character variable containing the factor levels of selected data variables. In case of numeric variables, the data values are stored (in textual form).
\hh{Ordering of levels in factor variables (XXX not sure where to put this, yet):
  What we are doing with the ordering of levels in factor variables, is to stick with the basic interpretation of factor variables as a type of variable that has both labels and an ordering of those labels. Whenever we assign a numeric value to the ordering, we refer to the associated score, which is an integer value from one to the number of categories, if not specified explicitly otherwise. This means in particular, that the first level of a categorical variable is mapped to the lowest value along the $y$ axis rather than the `top` value as e.g. when mapped to `fill`  in a barchart. }
\hh{This might lead to a visual insonsistency between the orderings in the levels of a categorical variable and an accompanying color legend. In those situations we suggest to reverse the order in the legend by using the command \code{guides(color = guide\_legend(reverse=TRUE))} as shown in the example in \autoref{sec:carcinoma}.}
\item \code{pcp\_class}: character variable containing the class information of a selected variable.
\item \code{pcp\_id}: integer variable identifying each observation in the original dataset. This variable will be used as grouping variable to identify which values should be connected by a line segment in the parallel coordinate plot.
\end{itemize}

\hh{XXX reordering variables in the parallel coordinate plot could be done before the selection by pcp\_select or after it by re-ordering the levels in the pcp\_x variable. We should probably include an example.}

\hh{XXX univariate transformations, such as reversing an axis for a variable can be done using a mutate statement before the variable selection. example? changing order of levels on a categorical variable or a log transform or square root transformation work the same. }

\subsection{Scaling}

\code{pcp\_scale(data, method)} scales the values on each axis and determines the relative relationship of the axes to each other.

\code{method} is a character string specifying the method to be used when transforming the values of each variable into a common y axis. By default, the method \code{uniminmax} is chosen, which univariately scales each variable into a range of [0,1] with a minimum at 0 and the maximum at 1. \code{globalminmax} maps the values across all axes into a an interval of [0,1]. This method should only be used if the values across all variables are comparable. \svp{XXX Need to discuss \code{std} here if you're going to use it in \autoref{fig:scale}.}
The method \code{robust} normalizes values univariately by mapping the median value to 0.5 and a robust 95\% confidence interval (based on the median absolute deviation) to an interval of 0 to 1.

%\hh{Does the method 'raw' do anything? I think we could have the same effect by simply skipping this part of the processing. It's a nice example, where something that needed para metrization in another implementation is automatically implemented here by not doing anything. }


<<colorscheme>>=
#####  Color Palette by Paletton.com
#####  Palette URL: http://paletton.com/#uid=3140R0kllllaFw0g0qFqFg0w0aF


# *** Primary color:
primary = c("#AA8939", "#FFE7AA", "#D4B66A", "#806115", "#553D00")

# *** Secondary color (1):

secondary = c("#5A2971", "#9974AA", "#784A8E", "#3F1255", "#270339")

# *** Secondary color (2):

tertiary = c("#277552", "#75B095", "#499371", "#0F5837", "#003B20")

#####  Generated by Paletton.com (c) 2002-2014
@

\autoref{fig:scale} shows  two of the scaling methods at the example of the olive oil data  \citep{ggobi, tourr, forina}: measurements of fatty acids in 572 olive oils from three different regions in Italy are visualized as parallel coordinate plots. Similar to the findings in \citet{ggobi}, we see that eicosenoic acid is only found in increased quantities in olive oils from Southern Italy. Quantities of oleic and linoleic acids allow a separation between olive oils from Sardinia and Northern Italy. Both scaling methods enable us to find these conclusions.

<<scale, fig.cap="Two scaling methods showing fatty acid compositions of  olive oils from different regions in Italy. The scaling methods roughly allow the same conclusions.", fig.height = 8, fig.width = 8>>=
#crabs <- read.csv("http://ggobi.org/book/data/australian-crabs.csv")
#prim7 <- read.csv("http://ggobi.org/book/data/prim7.csv")
data("olive", package="tourr")

oils <- olive %>% mutate(
  area = reorder(area, region)
)
# oils <- oils %>% mutate(
#   X = gsub("[0-9]+.", "", X),
#   X = reorder(X, area),
#   area = X
# )

# oils <- oils %>% mutate(
#     palmitic = -palmitic,
#     palmitoleic = -palmitoleic
#   )

dt1 <- oils %>%
  mutate(
    region=factor(region)
    ) %>%
  pcp_select(region, area, palmitic:eicosenoic) %>%
  pcp_scale(method = "uniminmax") %>%
  pcp_arrange()
dt1$scaling <- "uniminmax"

dt2 <- oils %>%
  mutate(
    region=factor(region)
    ) %>%
  pcp_select(region, area, palmitic:eicosenoic) %>%
  pcp_scale(method = "std") %>%
  pcp_arrange()
dt2$scaling <- "std"

dt <- rbind(dt1, dt2)


dt %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes() +
  geom_pcp(aes(colour = area), alpha = 0.5, overplot="none") +
  facet_grid(scaling~., labeller="label_both", scales="free_y") +
  scale_colour_manual(values = c(primary[c(2,4,3,1)], secondary[1:2], tertiary[1:3])) +
  theme_bw() +
  theme(legend.position = "bottom") +
  guides(colour=guide_legend(override.aes = list(alpha=1, size = 2), reverse=TRUE)) +
  scale_x_discrete(expand = expansion(add=0.3))
@

\subsection{Breaking ties on categorical axes}

\code{pcp\_arrange(data, method, space)} provides a rescaling of values on categorical axes to break ties. \code{method} is a parameter specifying which variables to use to break ties. The two implemented methods are \code{"from-left"} and \code{"from-right"}, meaning that ties are broken using a hierarchical ordering using variables' values from the left or the right, respectively. The parameter \code{scale} specifies the amount of the `y` axis to use for space between levels of categorical variables. By default, 5\% of the axis is used for spacing.

\hh{XXX hierarchical ordering seems to minimize line crossings - but I don't have a proof. If we have a reference on ordering metrics this might go well here}

\autoref{fig:alignment} shows several approaches of dealing with categorical variables in parallel coordinate plots.
The left-most panel shows two categorical variables and the typical net of lines that forms between them in an original parallel coordinate plot. The other three panels show three different approaches of breaking the ties resulting from the categorical variables, with our favored solution shown on the right: all observations are spaced out evenly. This results in a natural visualization of the marginal frequencies along each axis (additionally enhanced by the lightly greyed boxes grouping observations in the same category). The ordering of the observations within the level is such that a minimal number of line crossings occurs between the axes. This method of dealing with categorical variables is the one we propose in the generalized parallel coordinate plot. While it is aesthetically pleasing, it also allows us in the
 spirit of the original parallel coordinate plots to follow an individual observation from left to right through the plot even for  categorical variables.
The other two solutions in the middle panels of \autoref{fig:alignment} show
two intermediary solutions of breaking ties in categorical variables: jittering and equi-spaced (unordered) values.
<<alignment, fig.height = 3.5, fig.align="center", fig.cap="Four different approaches of dealing with categorical variables: the panel on the left shows the typical net of lines resulting from categorical variables in regular parallel coordinate plots. In the other three panels ties in categorical levels are broken using different approaches: from left to right, jittering, equi-spaced line segments and ordered equi-spaced line segments are shown. ">>=
set.seed(20200924)
x1 <- c(rep(1, 5), rep(2, 3), rep(3, 4))
x2 <- c(1,2,1,2,1,1,1,1,2,2,2,1)
jitter1 <- runif(n = 12, min = -0.1, max = 0.1)
jitter2 <- runif(n = 12, min = -0.1, max = 0.1)
y <- c("a", "b", "c")[x1]
dfnew <- tibble(v1 = x2, v2 = x1,
                v3 = as.factor(x1),
                v4 = as.factor(x2),
                z = y,
                v5 = x2 + jitter1,
                v6 = x1 + jitter2,
                v7 = x2 + c(0, -0, 0.05, -0.05, 0.1, 0.15, 0.20, 0.25, -0.1, -0.15, -0.2, 0.3)/0.05*0.083,
                v8 = (x1-1)/2+1 + c(0:4*0.05, 0:2*0.05, 3:0*(-0.05))/0.05*0.083 + c(rep(0,5), rep(-0.04, 3), rep(0,4)))

p1 <- dfnew %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour = z), size=1) +
  theme_bw() +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) +
  xlab("") + ylab("") +
  facet_grid(.~"Original PCP") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none") +
  scale_x_discrete(expand = expansion(add=0.05))



p2 <- dfnew %>%
  mutate(v1 = v4, v2 = v3) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp_boxes(boxwidth=0.3, fill="grey90", alpha=0.5) +
  geom_pcp_axes() +
  geom_pcp(aes(colour = z), size=1) +
  theme_bw() +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) +
  xlab("") + ylab("") +
  facet_grid(.~"GPCP style") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none") +
  ylim(c(0,1))+
  scale_x_discrete(expand = expansion(add=0.2))



p3 <- dfnew %>%
  mutate(v1 = v5, v2 = v6) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(size=1, aes(colour = z)) +
  theme_bw() + ylab("") +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) + xlab("") +
  facet_grid(.~"Jitter") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none")+
  scale_x_discrete(expand = expansion(add=0.05))

p4 <- dfnew %>%
  mutate(v1 = v7, v2 = v8) %>%
  pcp_select(v1:v2) %>%
  pcp_scale() %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(size=1, aes(colour = z)) +
  theme_bw() + ylab("") +
  scale_colour_manual(values=c( "darkorange", "purple4", "darkgreen")) + xlab("") +
  facet_grid(.~"Equally spaced") +
  theme(axis.title.y = NULL, axis.text.y = NULL, axis.ticks.y = NULL) +
  theme(legend.position="none")+
  scale_x_discrete(expand = expansion(add=0.05))

grid.arrange(p1, p3, p4, p2, nrow=1)
@


\section{The Generalized Parallel Coordinate Plot}

\hh{XXX We need to include some code somewhere to also show the 'how'.}

\subsection{Plotting Order of line segments}

One of the primary advantages of the generalized approach to dealing with categorical variables is the ability to follow a single observation throughout the plot. As the number of observations increase, this becomes less feasible because of overplotting of line segments, particularly for slightly larger data sets. As more observations and line segments are drawn, more lines cross each other, increasing the effort required to follow a polyline from one side of the plot to the other. \hh{XXX the order in which crossing lines are drawn is only visible when the lines have different colors.}
As a countermeasure we carefully control the order in which line segments are plotted.

Two methods to control this order are implemented and are regulated by the parameter \code{overplot}:

\begin{enumerate}
%
\item \code{"small-on-top"} groups of lines (defined by the same color) between categorical variables are are ordered by size and drawn from largest to smallest group.
%
\item \code{"none"} the order of the observations is left un-touched by the data wrangling process. This option allows the user to specify a certain  order before plotting.
%
\end{enumerate}
\hh{additional counter-measures: use $\alpha$-blending}

\hh{the option of \code{"none"} is very flexible.}


\section{Examples}
\subsection{Penguins}
%
<<penguins, fig.cap="Generalized Parallel Coordinate Plot of the Palmer penguins data.", fig.height=4, fig.width=8>>=
library(palmerpenguins)

penguins_pcp <- penguins %>%
    mutate(
        sex = ifelse(is.na(sex),"NA", as.character(sex))
    ) %>%
  filter(!is.na(body_mass_g)) %>%
  pcp_select(1,3:4, 1, 5:7) %>%
  pcp_scale() %>%
  pcp_arrange()

penguins_pcp %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes(boxwidth=0.1) +
  geom_pcp(aes(colour = sex), alpha = 0.8) +
  geom_pcp(aes(colour = sex), size =0.9,
           data = penguins_pcp %>% filter(sex=="NA")) +
  geom_pcp_labels(aes(label = pcp_level), alpha = .5) +
  theme_bw() +
  scale_colour_manual(values=c("#ff990050", "steelblue", "black")) +
  theme(legend.position="bottom") +
  ylab("") +
  xlab("Variable")
@

\autoref{fig:penguins} shows a first generalized parallel coordinate plot of the Palmer penguins data \citep{penguins}. The data consists of body measurements, such as weight, flipper length, bill length, and depth,  of three species of penguins. What can be seen is that Adelie penguins generally have smaller bill lengths than the other two species, while Gentoo penguins can be distinguished from the other two species by their relatively larger flipper lengths.



 The lines in \autoref{fig:penguins} are colored by sex of penguins. What can be seen is that within each species, the males tend to be larger in size and heavier than the females. For several of the penguins, sex could not be determined because either the sexing primer did not amplify or no blood sample was obtained \citep{penguins2}. These penguins are represented by black lines.  Based on these penguins' body measurements within the context of the other penguins, we can make some suggestions regarding their sex. \autoref{fig:penguins2} shows a facetted version of the previous generalized parallel coordinate plots. Facetted is done by species, note that the axes are re-scaled within each facet to make use of the full range in $y$. Chinstrap penguins are excluded because all of their individuals in the data have a gender assigned.
The general pattern of measurements of the Gentoo penguins suggests that all four individuals with missing sex information are female (for further evidence, we find from the original data  that their nest partners are all sexed as male - assuming that nest partners are male and female is not a perfect method, in particular, for penguins, which have been shown to live in same-sex partnerships. However, in all three studies only nests with breeding successes have been considered. More details can be found in \citet{penguins2}).
For Adelie penguins the situation is not quite as clear-cut, but based on body weight and bill length measurements the three lightest penguins might be female, while the heaviest one could be male. The fifth penguin walks the line between typical male and typical female measurements. \hh{XXX check nests for Adelies}




<<penguins2, fig.cap="Closer investigation of non-sexed Adelie and Gentoo penguins. The group\\_by call before pcp\\_scale is responsible for scaling by species.", fig.height = 6, fig.width = 8>>=
penguins_pcp <- penguins %>%
    filter(species != "Chinstrap") %>%
    mutate(
        sex = ifelse(is.na(sex),"NA", as.character(sex))
    ) %>%
  filter(!is.na(body_mass_g)) %>%
  pcp_select(3:4, 5:7) %>%
  group_by(species) %>%
  pcp_scale() %>%
  pcp_arrange()

# recalculate position by group
# XXXX pcp_arrange has to also do the tie-breaking by group.
penguins_pcp %>%
  ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp_boxes(boxwidth=0.1) +
  geom_pcp(aes(colour = sex), alpha = 0.8) +
  geom_pcp(aes(colour = sex), size =0.9,
           data = penguins_pcp %>% filter(sex=="NA")) +
  geom_pcp_labels(aes(label = pcp_level), alpha = .5) +
  theme_bw() +
  scale_colour_manual(values=c("#ff990050", "steelblue", "black")) +
  theme(legend.position="bottom") +
    facet_grid(species~.) +
  scale_x_discrete(expand = expansion(add=0.25))
@

\subsubsection{Ordering levels in variables and variables along the x axis}

<<prep-raw-penguin, warning = FALSE>>=
p1 <- penguins_raw
p1 <- p1 %>% separate(col=`Individual ID`, into=c("Nest", "Individ"), remove=FALSE, sep=-2)
names(p1)[12:15] <- c("CulmenL", "CulmenD", "FlipperL", "BodyMass")
p1 <- p1 %>% separate(Species, into=c("species", "foo2", "foo3", "foo4"), sep=" ") %>% select(-starts_with("foo")) # foos make R happy, because it doesn't throw away anything unexpected
@

\autoref{fig:ordering} shows the effect of re-ordering the levels of both the `species` and the `island` variable in the generalized parallel coordinate plots.

<<ordering, fig.cap="Both of the levels of the island and the species variable re-ordered to reflect that two of the species are each only found on one island.", fig.height=6, fig.width=8>>=
library(scales)
#cols <- hue_pal()(3)
cols <- rev(c("#535993", "#C5D068", "#D4856A"))

# #####  Color Palette by Paletton.com
# #####  Palette URL: http://paletton.com/#uid=33W0V0kllllaFw0g0qFqFg0w0aF
#
#
# *** Primary color:
#
#    shade 0 = #323875 = rgb( 50, 56,117) = rgba( 50, 56,117,1) = rgb0(0.196,0.22,0.459)
#    shade 1 = #7D82B0 = rgb(125,130,176) = rgba(125,130,176,1) = rgb0(0.49,0.51,0.69)
#    shade 2 = #535993 = rgb( 83, 89,147) = rgba( 83, 89,147,1) = rgb0(0.325,0.349,0.576)
#    shade 3 = #191F58 = rgb( 25, 31, 88) = rgba( 25, 31, 88,1) = rgb0(0.098,0.122,0.345)
#    shade 4 = #080D3B = rgb(  8, 13, 59) = rgba(  8, 13, 59,1) = rgb0(0.031,0.051,0.231)
#
# *** Secondary color (1):
#
#    shade 0 = #9AA637 = rgb(154,166, 55) = rgba(154,166, 55,1) = rgb0(0.604,0.651,0.216)
#    shade 1 = #F1FAA6 = rgb(241,250,166) = rgba(241,250,166,1) = rgb0(0.945,0.98,0.651)
#    shade 2 = #C5D068 = rgb(197,208,104) = rgba(197,208,104,1) = rgb0(0.773,0.816,0.408)
#    shade 3 = #727D15 = rgb(114,125, 21) = rgba(114,125, 21,1) = rgb0(0.447,0.49,0.082)
#    shade 4 = #4A5300 = rgb( 74, 83,  0) = rgba( 74, 83,  0,1) = rgb0(0.29,0.325,0)
#
# *** Secondary color (2):
#
#    shade 0 = #AA5639 = rgb(170, 86, 57) = rgba(170, 86, 57,1) = rgb0(0.667,0.337,0.224)
#    shade 1 = #FFC0AA = rgb(255,192,170) = rgba(255,192,170,1) = rgb0(1,0.753,0.667)
#    shade 2 = #D4856A = rgb(212,133,106) = rgba(212,133,106,1) = rgb0(0.831,0.522,0.416)
#    shade 3 = #803015 = rgb(128, 48, 21) = rgba(128, 48, 21,1) = rgb0(0.502,0.188,0.082)
#    shade 4 = #551600 = rgb( 85, 22,  0) = rgba( 85, 22,  0,1) = rgb0(0.333,0.086,0)



# First pcp
pp1 <- p1 %>% pcp_select(studyName, species, Island, CulmenL:Sex) %>%
  pcp_scale() %>% pcp_arrange() %>% ggplot(aes_pcp()) +
  geom_pcp_axes(colour="white") +
  geom_pcp(aes(colour=species), alpha=0.8, overplot="none") +
  geom_pcp_boxes(fill="white") +
  geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  ggtitle("Original order of levels and variables") +
  scale_colour_manual(values=c(cols[1], cols[2], cols[3]))

p1 <- p1 %>%   mutate(species=factor(species, levels=c("Chinstrap", "Adelie", "Gentoo"))) %>%
  mutate(island=factor(Island, levels=c("Dream", "Torgersen", "Biscoe")))


# Fourth pcp
pp2 <- p1 %>%
  pcp_select(studyName, species, island, CulmenL:Sex) %>%
#pp2 <- p1 %>% pcp_select(studyName, speciesC, islandC, CulmenL, `-CulmenD`, FlipperL:Sex) %>%
  pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
  geom_pcp_axes() +
  geom_pcp(aes(colour=species), alpha=0.8, overplot="none") +
  geom_pcp_boxes(fill="white") +
  geom_pcp_labels(alpha=1) +
  theme_bw() +
  xlab(NULL) + ylab(NULL) +
  theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
        legend.position="none") +
  scale_colour_manual(values=c(cols[2], cols[1], cols[3])) +
  ggtitle("Levels reordered to emphasize relationship between islands and species")

library(patchwork)
pp1 + pp2 + plot_layout(nrow = 2, byrow = FALSE)
@

The variables in \autoref{fig:penguins-variable-order} have been re-ordered
to allow the viewer to see what body measurements distinguish the species. Note that besides the re-ordering, the axes for Culmen depth is also reversed.
The plot shows that the Gentoo penguins are bigger, that Gentoo and Chinstrap are both only found on single islands, that Adelie and Chinstrap are distinguished by Culmen Length.
The plot does not show anything about the differences between male and female penguins.  Given the greater size of the males in general it may be better to split by male and female, ignoring the missing values.  The results are the same for both sexes and stand out more.  Interestingly,  some potential outliers that were not visible previously, now stand out.

\au{XXX Possible ordering approaches would be to use some kind of association measure or a matrix reordering algorithm for two categorical variables, medians by category or R2 from a linear model for continuous and categorical, correlations for two continuous variables.}

\au{XXX
Drawing pcps depends on what your goal might be.  It reminds me of rotating plots and all the optimisation criteria that were suggested for a variety of purposes.  They did not necessarily work well, but they suggested some ways to proceed and generally improved things a bit.  What criteria might be similarly helpful for pcps?
}

<<penguins-variable-order, fig.cap="Changing the order of the variables along the x-axis emphasizes the differences in body measurements between the species.", fig.height=6, fig.width=8>>=
# Reorder the variables, moving CulmenL to the right, and do case ordering from the left
# Invert the CulmenD variable (and use your minus notation :-))
p1 <- p1 %>% mutate(`-CulmenD`=-CulmenD)

# Fifth pcp
# p1 %>% pcp_select(studyName, speciesC, islandC, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
#   pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
#   geom_pcp_axes(colour="white") +
#   geom_pcp(aes(colour=speciesC)) +
#   geom_pcp_boxes(fill="white") +
#   geom_pcp_labels(fill="white", alpha=1) +
#   xlab(NULL) + ylab(NULL) +
#   theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
#         legend.position="none") +
#   scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

# Change the order of printing the colours to make Chinstrap stand out better
# Requires rearranging of dataset case order and using overplot="none"
p1 <- p1 %>% arrange(fct_rev(species))

# # Sixth pcp
# p1 %>% pcp_select(studyName, speciesC, islandC, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
#   pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
#   geom_pcp_axes(colour="white") +
#   geom_pcp(aes(colour=speciesC), overplot="none") +
#   geom_pcp_boxes(fill="white") +
#   geom_pcp_labels(fill="white", alpha=1) +
#   xlab(NULL) + ylab(NULL) +
#   theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
#         legend.position="none") +
#   scale_colour_manual(values=c(cols[2], cols[1], cols[3]))
#



# Splitting by sex (not faceting so that NAs are excluded and scales are individual)
# Seventh pcp
m1 <- p1 %>% filter(Sex=="MALE") %>% pcp_select(studyName, species, island, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
geom_pcp_axes() +
geom_pcp(aes(colour=species), overplot="none", alpha = 0.8) +
geom_pcp_boxes(fill="white") +
geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
xlab(NULL) + ylab(NULL) +
theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
legend.position="none") +
scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

f1 <- p1 %>% filter(Sex=="FEMALE") %>% pcp_select(studyName, species, island, `-CulmenD`, FlipperL, BodyMass, CulmenL, Sex) %>%
pcp_scale() %>% pcp_arrange(method="from-left") %>% ggplot(aes_pcp()) +
geom_pcp_axes() +
geom_pcp(aes(colour=species), overplot="none", alpha = 0.8) +
geom_pcp_boxes(fill="white") +
geom_pcp_labels(fill="white", alpha=1) +
  theme_bw() +
xlab(NULL) + ylab(NULL) +
theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(),
legend.position="none") +
scale_colour_manual(values=c(cols[2], cols[1], cols[3]))

#library(patchwork)
f1 + m1 + plot_layout(nrow = 2, byrow = FALSE)
@


\subsection{Getting a second, third, ... and seventh opinion}\label{sec:carcinoma}

\autoref{fig:carcinoma} shows data from \citet{agresti} published as part of the \code{poLCA} package \citep{polca}. Seven pathologists were asked to assess the same 118 slides for the presence or absence of carcinoma in the uterine cervix. Binary responses for each slide were recorded (yes/no).  Pathologists all agreed on about 25\% of slides, which they  considered to be carcinoma free, and a further 12.5\% of slides, which were considered to show carcinoma by all pathologists.
For the remaining 62.5\% of slides there was some disagreement. However, we see that this disagreement is not random. When pathologists are ordered (by moving the corresponding axes) left to right from fewest number of overall carcinoma diagnoses to highest number, we see that generally for a slide more pathologists make a carcinoma diagnosis  from left to right.
<<carcinoma, fig.cap="Pathologists' diagnoses of absence (no) or presence (yes) of carcinoma in the uterine cervix based on 118 slides. Each slide is shown by a polyline.", fig.height = 4, fig.width = 8>>=
data("carcinoma", package = "poLCA")
carcinoma$numdiag <- rowSums(carcinoma) - 7
carcinoma$any <- carcinoma$numdiag > 0

carcinoma[,1:7] <- carcinoma[,1:7] %>%
  purrr::map(.f = function(x) factor(x, labels =c("no", "yes"))) %>%
  data.frame()

carcinoma %>%
  pcp_select(6,4,3,1,7,5,2) %>%
  pcp_scale(method="raw") %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
    geom_pcp_axes() +
    geom_pcp_boxes() +
    geom_pcp(aes(colour = factor(numdiag))) +
    geom_pcp_labels(aes(label = pcp_level), alpha = .5) +
    scale_colour_brewer("Number of\ncarcinoma\ndiagnoses", palette ="Dark2") +
    theme_bw() +
    guides(color = guide_legend(reverse=TRUE)) +
  scale_x_discrete(expand = expansion(add=0.25))
@

\hh{note: in this example we do not need to scale the variables. Aside from the actual scale the values are ordered in the same way. }

\subsection{ASA Data expo 2006}

In this example, we re-visit a data set that was used for the ASA Data Expo in 2006. The `nasa` data, made available as part of the `ggpcp` package provides an extension to the data provided in the `GGally` package \cite{GGally}. It consists of monthly measurements of several climate variables, such as cloud coverage, temperature, pressure, and ozone values, captured on a 24x24 grid across Central America between 1995 and 2000.

Using a hierarchical clustering (based on Ward's distance) of all January  measurements of all climate variables and the elevation, we group locations into 6 clusters.
The resulting cluster membership can then be summarized visually. \autoref{fig:spatial} shows a tile plot of the geography colored by cluster. We see that the clusters have a very distinct geographic pattern.

<<prep-work-nasa>>=
wide <- nasa %>% dplyr::select(id, month, year, starts_with("cloud"), ozone, pressure, surftemp, elevation) %>%
  gather(key = variable, value = value, -id, -month, -year) %>%
  filter(month %in% c("Jan")) %>%
  unite(var_date, variable, year, month, sep="-") %>%
  spread(key=var_date, value)

d <- dist(wide[,-1])
cl <- hclust(d, method = "ward.D")

wide$cl2 <- cutree(cl, k = 2)
wide$cl3 <- cutree(cl, k = 3)
wide$cl4 <- cutree(cl, k = 4)
wide$cl5 <- cutree(cl, k = 5)
wide$cl6 <- cutree(cl, k = 6)
wide$cl7 <- cutree(cl, k = 7)
wide$cl8 <- cutree(cl, k = 8)
wide$cl9 <- cutree(cl, k = 9)
wide$cl10 <- cutree(cl, k = 10)

wide.sum <- nasa %>% dplyr::select(id, month, year, starts_with("cloud"), ozone, pressure, surftemp, elevation) %>%
  gather(key = variable, value = value, -id, -month, -year) %>%
  filter(month %in% c("Jan")) %>%
  group_by(id, variable, month) %>%
  summarize(
    value = mean(value)
  ) %>%
  unite(var_month, variable, month, sep="-") %>%
  spread(var_month, value)

wide <- wide %>% left_join(wide.sum, by="id")
@

<<spatial, fig.align="center", out.width="\\linewidth", fig.cap="Tile plot of the (gridded) geographic area underlying the data. Each tile is colored by its cluster membership.">>=
means <- wide %>%
  mutate(elevation = `elevation-1997-Jan`) %>%
  group_by(cl8) %>%
  summarize(across(52:59, .fns = mean))
means$type <- "cluster-means"

nasa_pcp <- wide %>%
  mutate(
    elevation = `elevation-1997-Jan`,
    type = "observed") %>%
  bind_rows(means) %>%
  pcp_select(53:59) %>%
  pcp_scale()


gg1 <- wide %>% separate(id, into=c("y", "x"), remove = FALSE) %>%
  mutate(x = as.numeric(x), y = as.numeric(y)) %>%
  ggplot(aes(x = x, y=y, fill=factor(cl8))) +
  geom_tile(alpha = 0.7, colour = "grey90", size=0.1) + scale_fill_brewer("Cluster", palette = "Paired") +
  xlab("Latitude") + ylab("Longitude") +
  coord_equal() +
  ggthemes::theme_map()

gg2 <- nasa_pcp %>%
  filter(type == "cluster-means") %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(colour=factor(cl8)), size = 1.25) +
  scale_colour_brewer("Cluster", palette = "Paired") +
  theme(legend.position = "none") +
  theme_bw() +
  ylab("") + xlab("") +
  guides(colour=guide_legend(override.aes = list(alpha=1, size = 2)))

gg1+gg2
@


<<clusters, fig.height = 5, fig.width = 8, fig.pos="H", fig.cap="Overview of all variables involved in the clustering. ", out.width='\\textwidth'>>=
nasa_pcp %>%
  filter(type == "observed") %>%
  ggplot(aes_pcp()) +
  geom_pcp(aes(colour=factor(cl8)), alpha = 0.3) +
  geom_pcp(#aes(colour=factor(cl8)),
    size=1, alpha = 0.6,
           data = nasa_pcp %>% filter(type == "cluster-means")) +
  facet_wrap(.~cl8, labeller="label_both", ncol=2) +
  scale_colour_brewer("Cluster", palette = "Paired") +
  theme(legend.position = "none") +
  theme_bw() +
  ylab("") + xlab("") +
  guides(colour=guide_legend(override.aes = list(alpha=1, size = 2)))
@

\hh{XXX changed the data for the clustering - need to adjust the description}
From the parallel coordinate plot in \autoref{fig:clusters} we see that cloud coverage in low, medium and high altitude distinguishes quite succinctly between some of the clusters. (Relative) temperatures in January are very effective at separating between clusters in the Southern and Northern hemisphere.
The connection between the US gulf coast line and the upper region of the Amazon (cluster 2) can probably be explained by a relatively low elevation combined with similar humidity levels.

A parallel coordinate plot allows us to visualize a part of the dendrogram corresponding to the hierarchical clustering.

<<old,fig.height = 3.5, fig.cap="Dendrogram showing number of clusters at each step of the hierarchical process using the old-style parallel coordinate plot.">>=
wide %>%
  pcp_select(cl2:cl10) %>%
  pcp_scale %>%
  ggplot(aes_pcp()) +
  geom_pcp() +
  xlab("Number of clusters") +
  ylab("")
@

Using the generalized parallel coordinate plots we can visualize the clustering process in plots similar to what \citet{clustergram1, clustergram2} coined the clustergram, see \autoref{fig:old} and \autoref{fig:clustergram}.
<<clustergram, fig.height = 3.5, fig.cap="Same dendrogram as above using the much more informative generalized parallel coordinate plot.">>=
wide %>%
  mutate(
    cl2 = factor(cl2),
    cl3 = factor(cl3),
    cl4 = factor(cl4),
    cl5 = factor(cl5),
    cl6 = factor(cl6),
    cl7 = factor(cl7),
    cl8 = factor(cl8),
    cl9 = factor(cl9),
    cl10 = factor(cl10)
  ) %>%
  pcp_select(cl2:cl10) %>%
  pcp_scale() %>%
  pcp_arrange() %>%
  ggplot(aes_pcp()) +
  geom_pcp_boxes( boxwidth=0.1, fill=NA) +
  geom_pcp(alpha = 0.5, aes(colour = factor(cl10))) +
  xlab("Number of clusters") +
  scale_colour_brewer("Cluster", palette="Paired") +
  ylab("") +
  guides(colour=guide_legend(override.aes = list(alpha=1)))
@

Along the x-axis the number of clusters are plotted with one PCP axis each, from two clusters (left) to 10 clusters (right most PCP axis). Each line corresponds to one location, lines are colored by cluster assignment in the ten-cluster solution. This essentially replicates  the dendrogram while providing information about the number of observations in each cluster as well as the relationship between successive clustering steps.

\section{Results}

%------------------------------------------------

\section{Discussion}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------


\bibliography{refs.bib}

%----------------------------------------------------------------------------------------

\end{document}

